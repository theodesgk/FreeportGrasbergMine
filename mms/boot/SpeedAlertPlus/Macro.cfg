#!/psw/cpp

#include <SpeedAlertPlus/SpeedLimits.cfg>

/* Speed Alert Enhancements */
symbol SpeedLimit

/* Set SA_TYPE */
#if #arch(pe)

#ifdef DELITE
#    define SATYPELITE
    symbol SA_TYPE _DELITE_
#else
    symbol SA_TYPE DE
#endif

#ifdef SATYPELITE

/* DELITE Macros */
macro SpeedPost w0.speedLbl label:$(SpeedLimit);w0.speedOutline map:y;w0.speedLbl map:y;WinMgr after:10:SpeedOff
macro SpeedOff w0.speedOutline map:n;w0.speedLbl map:n;w0.speedOutline label:""
macro SpeedShow w0.speedLbl label:$(SpeedLimit);w0.speedOutline label:$(SpeedMsg01);w0.speedOutline map:y;w0.speedLbl map:y
macro SpeedOver  KBEEP 1;SpeedShow;WinMgr after:2:SpeedOver2
macro SpeedOver2 w0.speedLbl map:n;WinMgr after:2:SpeedOver3
macro SpeedOver3 KBEEP 1;w0.speedLbl map:y;WinMgr after:2:SpeedOver4
macro SpeedOver4 w0.speedLbl map:n;WinMgr after:2:SpeedOver5
macro SpeedOver5 KBEEP 1;w0.speedLbl map:y;WinMgr after:2:SpeedOver6
macro SpeedOver6 w0.speedLbl map:n;WinMgr after:2:SpeedOff

#else

/* DE Macros */
symbol    ShowOvrMsg    0
symbol    ShowOvrCnt    0

macro    SpeedPost    ""
macro    SpeedOver    KBEEP 1;ShowOvrMsg 1;ShowOvrCnt 1;OverDisp
macro    PollSpeed    eq? $(ShowOvrMsg) 0 SpeedDisp;\
                      eq? $(ShowOvrMsg) 1 SpeedChkCnt;\
                      CheckGlobalSpeed
macro    SpeedDisp    setGpsVel;\
                      eq? "$(SpeedUnit)" "mph" UseMph; \
                      eq? "$(SpeedUnit)" "km/h" UseKph; \
                      UpdateStatBar "Speed" "$(velocity)\n$(SpUnitDisplay)"
macro    SpeedChkCnt  ShowOvrCnt $(+ $(ShowOvrCnt) 1);\
                      eq? $(max $(ShowOvrCnt) 16) $(ShowOvrCnt) EndSpeedOver
macro    SpeedShowOn  ShowOvrMsg 1
macro    SpeedShowOff ShowOvrMsg 0    

macro    EndSpeedOver ShowOvrMsg 0;ShowOvrCnt 0;UpdateStatBarClr "Speed" "White";UpdateStatBarSize "Speed" "small";UpdateStatBarImg "3" "";SpeedDisp 
macro    OverDisp     UpdateStatBarClr "Speed" "Black";UpdateStatBarSize "Speed" "medium";UpdateStatBarImg "3" "spdalert";UpdateStatBar "Speed" "$(SpeedLimit)"

#endif


symbol IsGood 1     /* indicates if GPS status has been good for some time */
symbol gpsSpeedVel  /* holds velocity after all integrity tests passed */
symbol allSpeedVel  /* holds velocity to be sent*/
symbol gpsX         /* GPS x coordinate */
symbol gpsY         /* GPS y coordinate */
symbol sentTime  0  /* time when speeding event was sent up */
symbol elapsedSend  /* time since last event was sent up */
symbol currTime  0  /* current uptime */
symbol IsSentGSL 1  /* indicates if current speeding event already was sent up */
symbol goodTime  0  /* time when GPS status returned to good */
symbol sentTime  0  /* time when speeding event was sent up */
symbol currTime  0  /* current uptime */

/*  Initial macro, called by Vsms once per second:
 *  Adds 1 second to the current uptime and then checks GPS status
 */
macro CheckGlobalSpeed\
      AddTime;\
      CheckGpsStatus
    
/* 
 *  Get GpsTruck filtered velocity, plus x and y coords. Only if filtered
 *  velocity is acceptable (i.e. non-negative), proceed to check for speeding.
 *  If DE version < 6.7.2 use only Gps Velocity, 6.7.2+ should use combinedSpeedData
 */
#if    (DEMAJOR == 6 && DEMINOR == 7 && DEMAINT >= 2) || (DEMAJOR > 6 || DEMINOR >= 8)
macro CheckGpsStatus\
    gpsSpeedVel $(GpsTruck velocity);\
    allSpeedVel $(GpsTruck combinedSpeedData);\
    gpsX $(GpsTruck x); gpsY $(GpsTruck y);\
    eq? $(IsGood) 0 eq? $(min $(gpsSpeedVel) 0) 0 SetGood;\
    eq? $(max $(gpsSpeedVel) -1) -1 IsGood:0;\
    eq? $(IsGood) 1 DoGlobalSpeedCheck

macro sendGSL\
    VS-EVENT 671154180 $(allSpeedVel) $(gpsX) $(gpsY) $(GlobalSpeedLimit)

#else

macro CheckGpsStatus\
    eq? $(usevFiltered) y gpsSpeedVel $(GpsTruck vFiltered);\
    eq? $(usevFiltered) n gpsSpeedVel $(GpsTruck velocity);\
    gpsX $(GpsTruck x); gpsY $(GpsTruck y);\
    eq? $(IsGood) 0 eq? $(min $(gpsSpeedVel) 0) 0 SetGood;\
    eq? $(max $(gpsSpeedVel) -1) -1 IsGood:0;\
    eq? $(IsGood) 1 DoGlobalSpeedCheck

macro sendGSL\
    VS-EVENT 671154180 $(gpsSpeedVel) $(gpsX) $(gpsY) $(GlobalSpeedLimit)

#endif


/*  Indicate that status is good again and record the time. *
 */
macro SetGood\
        IsGood 1; goodTime $(currTime)

/*  If speed lower than configurable upper likelihood limit (MaxVel)
 *  and above speeding limit, determine if an event needs to be sent out.
 */
macro DoGlobalSpeedCheck\
    eq? $(max $(gpsSpeedVel) $(MaxVel)) $(MaxVel) \
    ne? $(max $(GlobalSpeedLimit) $(gpsSpeedVel)) $(GlobalSpeedLimit) \
    eq? $(IsSentGSL) 0 SendGSLAndStop;\
    CheckNotGlobalSpeeding
    
/* 
 * Keep uptime seconds counter; after 11.57 continuous days (999999 sec)
 * it is reset to 0 again (should hardly ever happen)
 */
macro AddTime\
    currTime $(+ $(currTime) 1); eq? $(currTime) 1e6 ResetTimes

macro ResetTimes\
    currTime 0; goodTime 0; sentTime 0

/*  
 * Send up event, then set boolean var indicating this, and record the time.
 */
macro SendGSLAndStop\
    sendGSL;IsSentGSL 1; sentTime $(currTime)

    
/*
 * Respond to the query on whether the equipment
 * is exceeding the speed limit for that beacon
 */
out    VS-EVENT    0x0772    l?fddd    sendto up
    
#if !#arch(hub)

symbol tempStat        /* holds the result of GpsTruck query (status) */
symbol elapsedGood     /* time since GPS status returned to good */
    
/*  
 * Enable sending events again (i.e. reset IsSentGSL to 0)
 * ONLY if all of this is true:
 * (gpsSpeedVel < GlobalSpeedLimit) AND
 * (time elapsed since status went good >= MinGoodTime) AND
 * (time elapsed since last event was sent >= MinSendTime)
 * (IsSentGSL is not already 0)
 */
macro CheckNotGlobalSpeeding\
    elapsedGood $(- $(currTime) $(goodTime));\
    elapsedSend $(- $(currTime) $(sentTime));\
    eq? $(max $(GlobalSpeedLimit) $(gpsSpeedVel)) $(GlobalSpeedLimit) \
    eq? $(min $(elapsedGood) $(MinGoodTime)) $(MinGoodTime) \
    eq? $(min $(elapsedSend) $(MinSendTime)) $(MinSendTime) \
    ne? $(IsSentGSL) 0 IsSentGSL:0
    
#endif

#define LANG_FILE <SpeedAlertPlus/LANGUAGE/Macro.cfg>
#include LANG_FILE

#endif