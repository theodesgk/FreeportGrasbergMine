%!/psw/cpp
/*
 * * * * * * * * * * * * * * * * * * *
 *  DISPATCH Real-Time Firmware Module
 * Copyright (c) Modular Mining Systems, 1982-1998
 *               All Rights Reserved
 *  $RCSfile: Macro.cfg,v $
 * $Revision: 1.16 $
 *   $Author: olivas $
 *     $Date: 2015/07/14 23:39:58 $
 *    $State: Exp $
 *   Purpose: Macro configuration file 
 * * * * * * * * * * * * * * * * * * *
 */
#include <GpsSpeed/SpeedLimits.cfg>
/*
 * This code is called by Vsms.cfg every second to
 * check wheather the truck is exceeding the
 * Global Speed limit
 */

stack 8196
symbol IsGood 1    /* indicates if GPS status has been good for some time */
symbol gpsSpeedVel      /* holds velocity after all integrity tests passed */
symbol gpsX        /* GPS x coordinate */
symbol gpsY        /* GPS y coordinate */
symbol sentTime 0  /* time when speeding event was sent up */
symbol elapsedSend /* time since last event was sent up */
symbol currTime	0  /* current uptime */
symbol IsSentGSL 1 /* indicates if current speeding event already was sent up */
symbol goodTime 0	/* time when GPS status returned to good */
symbol sentTime 0	/* time when speeding event was sent up */
symbol currTime	0	/* current uptime */
symbol GpsFilterInitialized n
symbol usevFiltered n

macro InitVelocityFilter\
        GpsFilterInitialized y;\
        eq? $(GpsTruck vFilterEnabled) yes usevFiltered y

/*  Initial macro, called by Vsms once per second:			*
 *  Adds 1 second to the current uptime and then checks GPS status	*
 */
macro NewCycle\
        eq? $(GpsFilterInitialized) n InitVelocityFilter;\
	AddTime;\
	CheckGpsStatus
	
/* 
 *  Get GpsTruck filtered velocity, plus x and y coords. Only if filtered	    *
 *  velocity is acceptable (i.e. non-negative), proceed to check for speeding.	*
 */
macro CheckGpsStatus\
	eq? $(usevFiltered) y gpsSpeedVel $(GpsTruck vFiltered);\
	eq? $(usevFiltered) n gpsSpeedVel $(GpsTruck velocity);\
        gpsX $(GpsTruck x); gpsY $(GpsTruck y);\
	eq? $(IsGood) 0 eq? $(min $(gpsSpeedVel) 0) 0 SetGood;\
	eq? $(max $(gpsSpeedVel) -1) -1 IsGood:0;\
	eq? $(IsGood) 1 CheckGlobalSpeeding

/*  Indicate that status is good again and record the time. *
 */
macro SetGood\
        IsGood 1; goodTime $(currTime)

/*  If speed lower than configurable upper likelihood limit (MaxVel)	    *
 *  and above speeding limit, determine if an event needs to be sent out.   *
 */
macro CheckGlobalSpeeding\
	eq? $(max $(gpsSpeedVel) $(MaxVel)) $(MaxVel) \
	ne? $(max $(GlobalSpeedLimit) $(gpsSpeedVel)) $(GlobalSpeedLimit) \
	eq? $(IsSentGSL) 0 SendGSLAndStop;\
	CheckNotGlobalSpeeding
	
/* 
 * Keep uptime seconds counter; after 11.57 continuous days (999999 sec)	*
 * it is reset to 0 again (should hardly ever happen)				*
 */
macro AddTime\
	currTime $(+ $(currTime) 1); eq? $(currTime) 1e6 ResetTimes
macro ResetTimes\
	currTime 0; goodTime 0; sentTime 0
	
/*  
 * Send up event, then set boolean var indicating this, and record the time. *
 */
macro SendGSLAndStop\
	sendGSL;IsSentGSL 1; sentTime $(currTime)
macro sendGSL\
	VS-EVENT 671154180 $(GlobalSpeedLimit) $(gpsX) $(gpsY) $(gpsSpeedVel)
	
/*
 * Respond to the query on whether the equipment
 * is exceeding the speed limit for that beacon
 */
out	VS-EVENT	0x0772	l?fddd	sendto up
	
#if !#arch(hub)

symbol tempStat		/* holds the result of GpsTruck query (status) */
symbol elapsedGood	/* time since GPS status returned to good      */
	
/*  
 * Enable sending events again (i.e. reset IsSentGSL to 0)  *
 * ONLY if all of this is true:                             *
 * (gpsSpeedVel < GlobalSpeedLimit) AND                          *
 * (time elapsed since status went good >= MinGoodTime) AND *
 * (time elapsed since last event was sent >= MinSendTime)  *
 * (IsSentGSL is not already 0)                             *
 */
macro CheckNotGlobalSpeeding\
	elapsedGood $(- $(currTime) $(goodTime));\
	elapsedSend $(- $(currTime) $(sentTime));\
	eq? $(max $(GlobalSpeedLimit) $(gpsSpeedVel)) $(GlobalSpeedLimit) \
	eq? $(min $(elapsedGood) $(MinGoodTime)) $(MinGoodTime) \
	eq? $(min $(elapsedSend) $(MinSendTime)) $(MinSendTime) \
	ne? $(IsSentGSL) 0 IsSentGSL:0
	
#else

/*
 * Enable sending events again (i.e. reset IsSentGSL to 0)  *
 * ONLY if both of these is true:  				*
 * (gpsSpeedVel < GlobalSpeedLimit) AND				*
 * (time elapsed since last event was sent >= MinSendTime)	*
 */
macro CheckNotGlobalSpeeding\
	elapsedSend $(- $(currTime) $(sentTime));\
	eq? $(max $(GlobalSpeedLimit) $(gpsSpeedVel)) $(GlobalSpeedLimit) \
	eq? $(min $(elapsedSend) $(MinSendTime)) $(MinSendTime) IsSentGSL:0

#endif
