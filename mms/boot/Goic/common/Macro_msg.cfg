symbol	msgCount 0
symbol	currentMsg 0

/*
 * Store 10 lots of message text
 */
symbol	msgText.0
symbol	msgText.1
symbol	msgText.2
symbol	msgText.3
symbol	msgText.4
symbol	msgText.5
symbol	msgText.6
symbol	msgText.7
symbol	msgText.8
symbol	msgText.9

/*
 * Store who it was sent by
 */
symbol	msgFrom.0
symbol	msgFrom.1
symbol	msgFrom.2
symbol	msgFrom.3
symbol	msgFrom.4
symbol	msgFrom.5
symbol	msgFrom.6
symbol	msgFrom.7
symbol	msgFrom.8
symbol	msgFrom.9

/*
 * Store whether it has been read or not
 */
symbol	msgRead.0 1
symbol	msgRead.1 1
symbol	msgRead.2 1
symbol	msgRead.3 1
symbol	msgRead.4 1
symbol	msgRead.5 1
symbol	msgRead.6 1
symbol	msgRead.7 1
symbol	msgRead.8 1
symbol	msgRead.9 1

/*
 * Maximum number of messages that can
 * be stored on the CGC
 */
symbol	maxMsg 10

/*
 * Move existing messages down 1 spot to
 * make way for the new message coming in
 */
macro	MoveMessages	foreach '9 8 7 6 5 4 3 2 1';do msgText.\$2 \$(msgText.\$(- \$2 1));\
			foreach '9 8 7 6 5 4 3 2 1';do msgFrom.\$2 \$(msgFrom.\$(- \$2 1));\
			foreach '9 8 7 6 5 4 3 2 1';do msgRead.\$2 \$(msgRead.\$(- \$2 1))

/*
 * If the message utility is currently open then the 
 * message being viewed is going to be offset 1
 * position in the set of message-holding symbols
 * when a new message is received. Move the current
 * message by one position to compensate so the
 * message being viewed is in the same relative
 * position to the rest. Also used to toggle
 * between messages
 */
macro	SetCurrentMessage	ne? $(currentMsg) $(- $(maxMsg) 1) currentMsg $(+ $(currentMsg) 1);\
				ne? $(msgCount) 0 wMessage.msgnum label:$(+ $(currentMsg) 1);\
				eq? $(msgCount) 0 wMessage.msgnum label:0;\
				eq? $(msgCount) 0 currentMsg 0;\
				wMessage.msgcount label:$(msgCount);\
				SetScrollIcons

/*
 * Check to see whether all the messages were
 * read before turning off the blinking message-
 * waiting indicators.
 *
 * Called from the onunpost method of the wMessage screen
 */
macro	CheckMessageReadStatus	holder 0;\
				foreach '0 1 2 3 4 5 6 7 8 9';do eq? \$(msgRead.\$1) 0 holder 1;\
				statVal.0 $(holder)

/*
 * Message received - advance the existing messages
 * to the next position so the new one slots into
 * pos 0. Mark it as unread and start the indicator
 * light flashing (statVal 1 gets evaluated every 4
 * seconds)
 * As a last check, if the user was on the message screen
 * and no messages had been received previously execute one
 * ScrollBack operation to display the very first message
 * correctly
 */

macro	DoMessageIn	MoveMessages;\
			eq? $(actwin) wMessage SetCurrentMessage;\
			ne? $(actwin) wMessage currentMsg 0;\
			msgText.0 $1;\
			msgFrom.0 $2;\
			msgRead.0 0;\
			statVal.0 1;\
			ne? $(msgCount) $(maxMsg) msgCount $(+ $(msgCount) 1);\
			ne? $(actwin) wMessage CheckAutoMessagePost;\
			eq? $(msgCount) 1 ScrollBack


/*
 * Check the configuration value Cfg.5 to see if it's
 * non-zero. Switch to the wMessage screen for Cfg.5
 * seconds if it's not
 */
macro	CheckAutoMessagePost	ne? $(cfg.5) 0 WinMgr after:$(cfg.5):'PostLastWindow';\
				ne? $(cfg.5) 0 WinMgr window:wMessage

macro	PostLastWindow		WinMgr window:$(lastwin)

/*
 * Scroll to the next message - check if
 * the current message is number 10 (msgText.9)
 * and if so then don't scroll any further. Change
 * the next button icon to disabled to indicate it
 * can't go any further
 */

/*
 * Adjust the navigation (next/last) button
 * icons to grey out if the currently displayed
 * message is either the first (grey out the last
 * button) or the last (grey out the next button)
 * to indicate they're inactive
 */
macro	SetScrollIcons		eq? $(currentMsg) 0 wMessage.last icon:last_dis;\
                                ne? $(currentMsg) 0 wMessage.last icon:last;\
				eq? $(currentMsg) $(- $(msgCount) 1) wMessage.next icon:next_dis;\
                                ne? $(currentMsg) $(- $(msgCount) 1) wMessage.next icon:next;\
				eq? $(msgCount) 0 wMessage.next icon:next_dis;\
				eq? $(msgCount) 0 wMessage.last icon:last_dis

/*
 * Called by the wMessage.next button. Check to 
 * make sure that the current message isn't either
 * the maximum message number allowed (msgText.9)
 * and that it isn't the last message in the list
 * (currentMsg = msgCount - 1) before incrementing
 * the current message pointer
 */
macro	ScrollForward		holder 1;\
				eq? $(currentMsg) $(- $(maxMsg) 1) holder 0;\
				eq? $(currentMsg) $(- $(msgCount) 1) holder 0;\
				currentMsg $(+ $(currentMsg) $(holder));\
				SetScrollIcons;\
				DisplayMessage

/*
 * As per ScrollForward, however here the test
 * is simply to make sure we're not scrolling
 * back past msgText.0
 */
macro	ScrollBack		ne? $(currentMsg) 0 currentMsg $(- $(currentMsg) 1);\
				SetScrollIcons;\
				DisplayMessage

/*
 * Update the contents of the various display
 * labels on the window with the appropriate
 * msgText.n information (also readFrom.n, etc)
 */
macro	DisplayMessage		wMessage.text clear;\
				wMessage.text write:"$(msgText.$(currentMsg))";\
				wMessage.from label:"$(msgFrom.$(currentMsg))";\
				wMessage.replyto label:"$(msgFrom.$(currentMsg))";\
				eq? $(msgCount) 0 wMessage.msgnum label:0;\
				ne? $(msgCount) 0 wMessage.msgnum label:$(+ $(currentMsg) 1);\
				wMessage.msgcount label:$(msgCount);\
				msgRead.$(currentMsg) 1

macro	KeyMessage	nextAction SendMessage; kpaction:SendMessage;\
			eq? $(cfg.2) 1 Kp2 label:'$(cfgLbl.16)' post

macro	SendMessage	eq? "$(cfgLbl.17)" "$(wMessage.replyto label)" MESSAGE "\$(Kp2.Disp label)";\
			ne? "$(cfgLbl.17)" "$(wMessage.replyto label)" MESSAGE "\$(Kp2.Disp label)" "\$(wMessage.replyto label)"

/* In the absence of a sending address set it to cfgLbl.17 (Dispatch) */
macro	SetSendTo	eq? "$(wMessage.replyto label)" "" wMessage.replyto label:"$(cfgLbl.17)"
macro	SetDestination	args
