%!/psw/cpp
/*
 * * * * * * * * * * * * * * * * * * *
 *  DISPATCH Real-Time Firmware Module
 * Copyright (c) Modular Mining Systems, 1982-1996
 *               All Rights Reserved
 *  $RCSfile: Macro.cfg,v $
 * $Revision: 1.3 $
 *   $Author: latum $
 *     $Date: 2006/06/08 21:34:04 $
 *    $State: Exp $
 *   Purpose: Macro.cfg extensions for drill monitoring
 *	      system support. Data is read by Plc interface
 * * * * * * * * * * * * * * * * * * *
 */


/*
 *  we include the main configuration file for the drill hardware.
 */
#include <PlcDrill/Drill.h>

/*
 * default if client did not configure it in Drill.h
 * when do we update drilling rate etc.
 */
#if !defined(UPDGC_COUNT)
#       define UPDGC_COUNT 5
#endif

/*
 * default if client did not configure it in Drill.h
 * when do we update gauges
 */
#if !defined(UPDGAU_COUNT)
#       define UPDGAU_COUNT 5
#endif

 
/*
 * void vrates(int opt);
 *
 * Transmit one of the following rate vectors in A$RATES packet.
 *
 * opt:0	penetration rate
 * opt:1	RPM
 * opt:2	Motor Amps
 * opt:3	Pull Down Force
 * opt:4 	Bit Air Pressure
 * opt:-1	All of the above
 */
in	VRATES          0x92    d       send$1

/*
 * void kdrill(char *bitDepth, char *penRate, char *depthFromBottom);
 *
 * Transmit these parameters to operator interface.
 */
out     KDRILL          0x5d    sss     sendto Goic

/*
 * Transmit rate vector upstream.  First element of vector
 * contains one of the `vrates' option bytes; remainder contains
 * the 8-bit data vectors.
 */
out     A$RATES         0x93    [b]d    sendto up

/*
 * define symbols where we save the pure Plc values as we get them from
 * the interface
 * here again the meaning of those values ( see DrillPlc/Macro.cfg and
 * keep it in sync, project engineers will love you for that)
 * 
 *  0. number of ticks (constantly updated)
 *  1. RPM in Hz (constantly updated)
 *  2. Air Bit Pressure (constantly updated)
 *  3. Torque (constantly updated)
 *  4. Pull Down Pressure (constantly updated)
 *  5. number of ticks (every DISTPERSAMPLE updated)
 *  6. RPM in Hz (every DISTPERSAMPLE updated)
 *  7. Air Bit Pressure (every DISTPERSAMPLE updated)
 *  8. Torque (every DISTPERSAMPLE updated)
 *  9. Pull Down Pressure (every DISTPERSAMPLE updated)
 * 10. Penetration Rate (constantly updated)
 *
 */
symbol slot0 0
symbol slot1 0
symbol slot2 0
symbol slot3 0
symbol slot4 0
symbol slot5 0
symbol slot6 0
symbol slot7 0
symbol slot8 0
symbol slot9 0
symbol slot10 0
symbol slot11 0
symbol slot12 0

macro zeroSlots foreach '0 1 2 3 4 5 6 7 8 9 10 11 12';do 'slot\$1 0'

symbol prevSlot5 0    /* used to store latest tick count when SAMPLE was updated */

macro setPlcValues MBUS-REQ 100; MBUS-REQ 102 STEELLENGTH; MBUS-REQ 103 SHAFTPERSAMPLE; \
                   MBUS-REQ 104 SHAFTPERDIST; MBUS-REQ 105 DRILLTYPE

/* poll DillPlc via Modbus, request data, DrillPlc sends 
 * a vector via MBUS-DATA back or does some action on DrillPlc
 * interface
 *
 * opt = 1   send only data relevant for genric CGC update (for KDRILL)
 * opt = 2   send usual profile data for gauges (for KDATA)
 * opt = 0   send all slots ( necessary for A$RATES)
 * opt = 100 zero shaft
 * opt = 101 add shaft 
 * opt = 102 steel length
 * opt = 103 distance per sample
 * opt = 104 shaft per distance 
 * opt = 105 drill type (rotation or hammer drill) 
 *    see also boot/DrillPlc/Macro.cfg
 */
out	MBUS-REQ	0x1c4	b?d 	sendto DrillPlc 
symbol  rate            0.0
symbol  depth           0.0
symbol  bottom          0.0
symbol  index           0
symbol  act             1
symbol  sav             0
macro   GCZeroDepth     rate 0.0; prevSlot5 0; zeroSlots; setPlcValues
/*macro   GCZeroDepth     zeroSlots;depth 0;bottom 0;rate 0.0; prevSlot5 0; zeroSlots; setPlcValues*/
macro   GCAddRod        MBUS-REQ 101 
macro   GCStartAddRod   act 0 
macro   GCEndAddRod     act 1;GCAddRod
/* this has no effect yet as we can not add a variable length
 * via the DrillPlc interface, maybe in the future
 */
macro   GCAddRodLength  MBUS-REQ 102 $1; MBUS-REQ 101

macro   setDepth        depth $(/ $(slot0) SHAFTPERDIST)
macro   setBottom       bottom $(max $(bottom) $(depth))
macro   setIndex        index $(/ $(slot5) SHAFTPERSAMPLE)
macro   sendUpdate      KDRILL $(depth) $(rate) $(- $(bottom) $(depth))
macro   drillRate       rate $(/ $(* $(slot10) 360.0) SHAFTPERDIST)    /* penetration rate as given from Plc */
macro   kdrillUpdate    eq? $(act) 1 setDepth;setBottom;sendUpdate
/* the following is a temporal replacement because the current Macro object
 * crashes during macro expansion 
 */
macro   kdrillUpdate    eq? $(slot0) 0 bottom 0.0;eq? $(act) 1 depth $(/ $(slot0) SHAFTPERDIST); bottom $(max $(bottom) $(depth));KDRILL $(depth) $(rate) $(- $(bottom) $(depth))
/* this macro triggers the Plc interface to read the slots and send them all
 * (MBUS-REQ 0) back, they will be catched by MBUS-DATA and the data will be
 * assigned to slot0...slot12; setMaster will do the maths with these slots
 */
macro 	pollPlc		MBUS-REQ 0


macro   samp0           prof0 $(index):PROF0
macro   samp1           prof1 $(index):PROF1
macro   samp2           prof2 $(index):PROF2
macro   samp3           prof3 $(index):PROF3
macro   samp4           prof4 $(index):PROF4
/*
 * can we send more than a vector of five to drill_act.frm ??? 
 * this is just a preparation to vibration also
 */
macro   samp5           prof5 $(index):PROF5
macro   samp6           prof6 $(index):PROF6

/* drillSample fills the prof1...prof6 vectors every DISTPERSAMPLE */
#if defined(PROF6)
macro   drillSample     eq? $(act) 1 setIndex;samp0;samp1;samp2;samp3;samp4;samp5;samp6
#else
macro   drillSample     eq? $(act) 1 setIndex;samp0;samp1;samp2;samp3;samp4;samp5
#endif

/* 
 * we could do that in a different way: fill only when slot5 is geater than prevSlot5
 * this would be somehow safer
 *
 * macro addSampleToVec setIndex;samp0;samp1;samp2;samp3;samp4;samp5;samp6; prevSlot5:$(slot5)
 * macro checkSampleCntChange eq? $(max $(prevSlot5) $(slot5)) $(slot5) addSampleToVec
 * macro drillSample  eq? $(act) 1 checkSampleCntChange
 *
 */

/* on VRATES request send out the prof0...prof6 vectors (up to MAXSAMPLES in a vector)*/
macro   send0           prof0 0:0;A\$RATES $(subvec prof0:$(+ $(index) 1)) DISTPERSAMPLE
macro   send1           prof1 0:1;A\$RATES $(subvec prof1:$(+ $(index) 1)) DISTPERSAMPLE
macro   send2           prof2 0:2;A\$RATES $(subvec prof2:$(+ $(index) 1)) DISTPERSAMPLE
macro   send3           prof3 0:3;A\$RATES $(subvec prof3:$(+ $(index) 1)) DISTPERSAMPLE
macro   send4           prof4 0:4;A\$RATES $(subvec prof4:$(+ $(index) 1)) DISTPERSAMPLE
/* can we send more than a vector of five to drill_act.frm ??? */
macro   send5           prof5 0:5;A\$RATES $(subvec prof5:$(+ $(index) 1)) DISTPERSAMPLE
macro   send6           prof6 0:6;A\$RATES $(subvec prof6:$(+ $(index) 1)) DISTPERSAMPLE

#if defined(PROF6)
macro   send-1          send0;send1;send2;send3;send4;send5;send6
#else
macro   send-1          send0;send1;send2;send3;send4;send5
#endif

/*
 *  KDATA rpc to be sent to Goic, it is the default anyway
 */
out     KDATA   0x97    [d]     sendto Goic

/*
 * setup a periodic update of realtime data to the CGC, if so
 * desired. For this functionality to be enabled, you must at least
 * define a macro 'REALTIMEDATA' in your Drill.h, for example:
 *
 * #define REALTIMEDATA $(slot10) $(slot1) $(slot2) $(slot3) $(slot4)
 *
 * By default, this functionality is not active
 */


#if defined(REALTIMEDATA)
macro kdataUpdate KDATA [ REALTIMEDATA ]
#else
macro kdataUpdate
#endif



/*
 * setMaster controls the action which should be done after receiving a MBUS-DATA rpc
 * in DrillVsms interface this is driven by Vsms counters, we use our own
 * counters which are based on the frequency we poll the Plc interface 
 * (see Vsms every:"frequency in msecs":pollPlc)
 * our own counters are integer multiples of this value
 * setCounters sets each available counter and sets it to zero for
 * taking action
 */

symbol UpdGcCnt 0
symbol UpdGauCnt 0

/* can be used for client specific counters */
macro cliCounters

macro setCounters \
       eq? $(min $(UpdGcCnt) UPDGC_COUNT) $(UpdGcCnt) UpdGcCnt:$(+ $(UpdGcCnt) + 1);\
       eq?  UPDGC_COUNT $(UpdGcCnt) UpdGcCnt:0;\
       eq? $(min $(UpdGauCnt) UPDGAU_COUNT) $(UpdGauCnt) UpdGauCnt:$(+ $(UpdGauCnt) + 1);\
       eq?  UPDGAU_COUNT $(UpdGauCnt) UpdGauCnt:0;\
       cliCounters


macro setMaster setCounters; drillRate; drillSample; eq? $(UpdGcCnt) 0 kdrillUpdate; eq? $(UpdGauCnt) 0 kdataUpdate

/* if we get rpc from Plc via Gsp invoke data gathering
 * corresponds to Vsms Pc0, Pc1 readings, this rpc is 
 * triggered by an explicit MBUS-REQ rpc sent to DrillPlc
 */
macro  capturePlcData foreach $1;do 'slot\$1 \$2'; setMaster
in	MBUS-DATA	0x1c0	[d]	capturePlcData

/*
 *	debugging macros 
 */
macro printSlots foreach '0 1 2 3 4 5 6 7 8 9 10 11 12';do 'echo slot\$1 : \$(slot\$1)'; echo 'prevSlot5 : $(prevSlot5)'
macro printkdrill echo 'depth: $(depth) rate: $(rate) diff: $(- $(bottom) $(depth)) bottom: $(bottom)'
macro printCounts echo 'Cnt Gauges: $(UpdGauCnt) Cnt KDRILL: $(UpdGcCnt) ARATES index: $(index)'
