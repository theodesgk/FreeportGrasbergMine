%!/psw/cpp

/*
 * * * * * * * * * * * * * * * * * * *
 *  DISPATCH Real-Time Firmware Module
 * Copyright (c) Modular Mining Systems, 1982-1996
 *               All Rights Reserved
 *  $RCSfile: PS_Macro.cfg,v $
 * $Revision: 1.17 $
 *   $Author: dcitron $
 *     $Date: 2014/07/28 23:52:52 $
 *    $State: Exp $
 *   Purpose: GOIC object configuration file.
 * * * * * * * * * * * * * * * * * * *
 */
/* Prestart check stuff */

#include <Goic/English/PS_Message.cfg>

#if #arch(cgc)
symbol	colorprestart 1
#else
symbol	colorprestart 0
#endif

/* default to classic original version of Prestart */
symbol PSVer	Prestart

symbol comment None
symbol ps.0 0
symbol ps.1 0
symbol ps.2 0
symbol ps.3 0
symbol ps.4 0
symbol ps.5 0
symbol ps.6 0
symbol ps.7 0
symbol ps.8 0
symbol ps.9 0

/* CfgPassFail.2 is used for items that are not used */
symbol	CfgPassFail.1	Fail
symbol	CfgPassFail.0	Pass
symbol	CfgPassFail.2	''
symbol	PsList		0
symbol	clItem
symbol	pg		0
symbol	PgMenuItems	
symbol	temp		
symbol	curritem	0
symbol	currval		0
symbol  curcmntval	0
symbol	PSstarted	0

macro	PSRefresh	$(PSVer).Label label:"$(PrestartTitle.$(PsList)) - Page $(+ $(pg) 1) of $(+ $(lastpage.$(PsList)) 1)";foreach $(PsInit.$(PsList).$(pg));do mapbuttons
macro	mapbuttons	currval $(min $(ps.$(PsList).$(pg).$1) 1);curritem $1;eq? "$2" "-1" hidebutton;ne? "$2" "-1" showbutton
macro	hidebutton	$(PSVer).T$1 map:no
macro	showbutton	$(PSVer).T$1 map:yes;SetColor.$(currval);SetIcon 
macro	addPgMenuItems	temp $(PgMenuItems);foreach $(PSVarList$(lastpage.$(PsList)));do createMenu
macro	createMenu	temp $(PgMenuItems);PgMenuItems $(temp) $(+ $2 1)
/* fixed for ver 3.0 */
macro	createPgMenu	KMENU PgMenu [ $(PgMenuItems) ]
macro	createPgMenu	PgMenu$(lastpage.$(PsList))
macro	PageMenu	PgMenu action:displayPage post
macro	displayPage	pg $(- $1 1);PSRefresh
macro	PgMenu0		KMENU PgMenu [ 1 ]
macro	PgMenu1		KMENU PgMenu [ 1 2 ]
macro	PgMenu2		KMENU PgMenu [ 1 2 3 ]
macro	PgMenu3		KMENU PgMenu [ 1 2 3 4 ]
macro	PgMenu4		KMENU PgMenu [ 1 2 3 4 5 ]
macro	PgMenu5		KMENU PgMenu [ 1 2 3 4 5 6 ]
macro	PgMenu6		KMENU PgMenu [ 1 2 3 4 5 6 7 ]
macro	PgMenu7		KMENU PgMenu [ 1 2 3 4 5 6 7 8 ]
macro	PgMenu8		KMENU PgMenu [ 1 2 3 4 5 6 7 8 9 ]
macro	PgMenu9		KMENU PgMenu [ 1 2 3 4 5 6 7 8 9 10 ]

/* modifications for ver 3.0
 * due to the way v3.0 refreshes we don't want set pg higher then lastpage so use temp instead
 */
#macro	nextPage	pg $(+ $(pg) 1); eq? "$(pg)" "$(+ $(lastpage) 1)" pg 0;PSRefresh
macro	nextPage	temp $(+ $(pg) 1);eq? "$(temp)" "$(+ $(lastpage.$(PsList)) 1)" pg 0;ne? "$(temp)" "$(+ $(lastpage.$(PsList)) 1)" pg $(temp);PSRefresh
#macro	prevPage	pg $(- $(pg) 1); eq? "$(pg)" "-1" pg $(lastpage);PSRefresh
macro	prevPage	temp $(- $(pg) 1);eq? "$(temp)" "-1" pg $(lastpage.$(PsList));ne? "$(temp)" "-1" pg $(temp);PSRefresh

symbol	PSVarList0	0
symbol	PSVarList1	0 1
symbol	PSVarList2	0 1 2
symbol	PSVarList3	0 1 2 3
symbol	PSVarList4	0 1 2 3 4
symbol	PSVarList5	0 1 2 3 4 5
symbol	PSVarList6	0 1 2 3 4 5 6
symbol	PSVarList7	0 1 2 3 4 5 6 7
symbol	PSVarList8	0 1 2 3 4 5 6 7 8
symbol	PSVarList9	0 1 2 3 4 5 6 7 8 9

#define	INT_RPC	0xa000
symbol	psTemp
symbol	psTemp2
symbol  pfTemp1
symbol  pfTemp2
symbol	piTemp1
symbol	piTemp2
symbol	bitmask
symbol	PsValue
symbol	PsDoNotOperate
symbol	PsNoOperateEnum	3
message DoNotOperateLbl Do Not Operate Equipment!
message PsCritFailLbl   Critical Pre-Start Items failed
macro	PsTellNoOperate	KDISP "$(DoNotOperateLbl)";KACK 1 "$(PsCritFailLbl)"
in	LoopAllItems	INT_RPC	ds	foreach $(PsInit.$(PsList).$1);do ne? \$2 2 $2 $1 \$1
/* ML rounds to nearest number after division unlike PTX so an integer division function must be added to avoid this incosistency: */
#if #arch(pe)
	in	IntDiv		INT_RPC	dd	return $(/ $1 $2)
#else
	in	IntDiv		INT_RPC	dd	return $(/ $(- $1 $(% $1 $2)) $2)
#endif
in	UnmaskActionBit	INT_RPC	d	ne? $(IntDiv $(% $(psTemp2) $(psTemp)) $(bitmask)) 0 PsValue $(+ $(PsValue) $1);bitmask $(psTemp);psTemp $(* $(psTemp) 2)
in	UnmaskItem	INT_RPC	dd	PsValue 0;UnmaskActionBit 1;UnmaskActionBit 2;PsAction.$(PsList).$1.$2 $(PsValue)
in	UnmaskActions	INT_RPC	dd	psTemp2 $2;bitmask 1;psTemp 2;LoopAllItems $1 UnmaskItem
in	PsChkNoOperate	INT_RPC	dd	eq? $(PsAction.$(PsList).$1.$2) $(PsNoOperateEnum) eq? $(ps.$(PsList).$1.$2) 1 PsDoNotOperate 1
/* this is GCDO'd by central: */
in	doPsUnmaskActs	INT_RPC	[d]	foreach $1;do UnmaskActions \$1 \$2

macro   setPassFail     Cfg.0.0.
macro	ResetText	foreach $(PSVarList$(lastpage.$(PsList)));	do 'temp \$2;DoResetText';
macro	DoResetText	foreach $(PsInit.$(PsList).$(temp));do 'pfTemp1 \$1;pfTemp2 \$2;DoResetText2'
macro   DoResetText2    Cfg.ps.$(PsList).$(temp).$(pfTemp1) \$(CfgPassFail.$(pfTemp2));
macro	ResetNums	foreach $(PSVarList$(lastpage.$(PsList)));	do 'temp \$2;DoResetNums'
macro	DoResetNums	foreach $(PsInit.$(PsList).$(temp));		do ps.$(PsList).$(temp).\$1 \$2
macro	ResetItems	foreach $(PSVarList$(lastpage.$(PsList)));	do 'temp \$2;DoResetItems'
macro	DoResetItems	foreach $(PsInit.$(PsList).$(temp));		do 'piTemp1 \$1; piTemp2 \$2; DoResetItems2'
macro	DoResetItems2	foreach $(PsInit.$(PsList).$(temp));		do 'pi.$(PsList).$(temp).$(piTemp1) 1;Cfg.pi.$(PsList).$(temp).$(piTemp1) ""'
macro	ResetAllPS	ResetText;ResetNums;ResetItems
macro	InitPS		ResetAllPS
macro	PassPSVars	foreach $(PSVarList7);do Cfg.ps.$(PsList).$(pg).\$2 \$(CfgPassFail.0);do ps.$(PsList).$(pg).\$2 0
macro	BundleAll	PsDoNotOperate 0;foreach $(PSVarList$(lastpage.$(PsList)));do 'temp \$2;BundleIt';ne? $(PsDoNotOperate) 0 PsTellNoOperate
macro	BundleIt	ps.$(temp) $(+ $(* $(ps.$(PsList).$(temp).0) 1) $(* $(ps.$(PsList).$(temp).1) 2) $(* $(ps.$(PsList).$(temp).2) 4) $(* $(ps.$(PsList).$(temp).3) 8) $(* $(ps.$(PsList).$(temp).4) 16) $(* $(ps.$(PsList).$(temp).5) 32) $(* $(ps.$(PsList).$(temp).6) 64) $(* $(ps.$(PsList).$(temp).7) 128));LoopAllItems $(temp) PsChkNoOperate

/* fixed for ver 3.0
 * rpc args that are arrays need to be put in []
 */
macro	SendPrestart0	eq? "$(comment)" "" comment None;BundleAll;PRESTART $(pstype) "$(PsList)|$(comment)" [ $(ps.0) ];ResetText;ResetNums;pg 0;PgMenuItems '';WinMgr window:w0
macro	SendPrestart1	eq? "$(comment)" "" comment None;BundleAll;PRESTART $(pstype) "$(PsList)|$(comment)" [ $(ps.0) $(ps.1) ];ResetText;ResetNums;pg 0;PgMenuItems '';WinMgr window:w0
macro	SendPrestart2	eq? "$(comment)" "" comment None;BundleAll;PRESTART $(pstype) "$(PsList)|$(comment)" [ $(ps.0) $(ps.1) $(ps.2) ];ResetText;ResetNums;pg 0;PgMenuItems '';WinMgr window:w0
macro	SendPrestart3	eq? "$(comment)" "" comment None;BundleAll;PRESTART $(pstype) "$(PsList)|$(comment)" [ $(ps.0) $(ps.1) $(ps.2) $(ps.3) ];ResetText;ResetNums;pg 0;PgMenuItems '';WinMgr window:w0
macro	SendPrestart4	eq? "$(comment)" "" comment None;BundleAll;PRESTART $(pstype) "$(PsList)|$(comment)" [ $(ps.0) $(ps.1) $(ps.2) $(ps.3) $(ps.4)] ;ResetText;ResetNums;pg 0;PgMenuItems '';WinMgr window:w0
macro	SendPrestart5	eq? "$(comment)" "" comment None;BundleAll;PRESTART $(pstype) "$(PsList)|$(comment)" [ $(ps.0) $(ps.1) $(ps.2) $(ps.3) $(ps.4) $(ps.5) ];ResetText;ResetNums;pg 0;PgMenuItems '';WinMgr window:w0
macro	SendPrestart6	eq? "$(comment)" "" comment None;BundleAll;PRESTART $(pstype) "$(PsList)|$(comment)" [ $(ps.0) $(ps.1) $(ps.2) $(ps.3) $(ps.4) $(ps.5) $(ps.6) ];ResetText;ResetNums;pg 0;PgMenuItems '';WinMgr window:w0
macro	SendPrestart7	eq? "$(comment)" "" comment None;BundleAll;PRESTART $(pstype) "$(PsList)|$(comment)" [ $(ps.0) $(ps.1) $(ps.2) $(ps.3) $(ps.4) $(ps.5) $(ps.6) $(ps.7) ];ResetText;ResetNums;pg 0;PgMenuItems '';WinMgr window:w0
macro	SendPrestart8	eq? "$(comment)" "" comment None;BundleAll;PRESTART $(pstype) "$(PsList)|$(comment)" [ $(ps.0) $(ps.1) $(ps.2) $(ps.3) $(ps.4) $(ps.5) $(ps.6) $(ps.7) $(ps.8) ];ResetText;ResetNums;pg 0;PgMenuItems '';WinMgr window:w0
macro	SendPrestart9	eq? "$(comment)" "" comment None;BundleAll;PRESTART $(pstype) "$(PsList)|$(comment)" [ $(ps.0) $(ps.1) $(ps.2) $(ps.3) $(ps.4) $(ps.5) $(ps.6) $(ps.7) $(ps.8) $(ps.9) ];ResetText;ResetNums;pg 0;PgMenuItems '';WinMgr window:w0

/* if a prestart doesn't get loaded this will just exit prestart */
macro	SendPrestartnil WinMgr window:w0
#out	PRESTART  0x028  sbbbbbbbb  sendto up
#out	PRESTART  0x028  s[b]  sendto up
#out	TOGGLE	0x0a9	ss	$1 $(% $(+ $(Macro $1) 1 ) 2 );Cfg.$1 $(CfgPassFail.$(Macro $1));curritem $2;SetColor.$(Macro $1)
/* fixed for ver 3.0
 * string args are put in parens except last arg
 * switched order of args and changed first one to number
 */
out	TOGGLE	0x0a9	ds	$2 $(min $($2) 1);$2 $(- 1 $($2));Cfg.$2 $(CfgPassFail.$($2));curritem $1;SetColor.$($2);PSstarted 1
#out	SETCOLOR 0x0aa	ss	eq "$1" "Fail" $2 colors:No;eq "$1" "Pass" $2 colors:Yes
macro	SetColor.1	$(PSVer).T$(curritem) colors:Fail
macro	SetColor.0	$(PSVer).T$(curritem) colors:Pass
macro	ItemColor.1	pi.$(PsList).$(pg).$(curritem) 1; $(PSVer).PF$(curritem) colors:default
macro	ItemColor.0	pi.$(PsList).$(pg).$(curritem) 0; $(PSVer).PF$(curritem) colors:Pass
macro	SetIcon		$(PSVer).T$(curritem) icon:$(PsIcon.$(PsList).$(pg).$(curritem))
macro	kpCommentPS kpaction 'showComment';Kp2 label:'Enter Comment' post
macro	kpItmCmntPS kpaction 'sendItmCmnt';Kp2.Disp label:$(Cfg.pi.$(PsList).$(pg).$(curritem));Kp2 label:$(CfgPs.$(PsList).$(pg).$(curritem)) post
macro	showComment comment $(Kp2.Disp label)
macro	sendItmCmnt	eq? $(Kp2.Disp label) $(nil) ItemColor.1;\
			ne? $(Kp2.Disp label) $(nil) ItemColor.0;\
			Cfg.pi.$(PsList).$(pg).$(curritem) $(Kp2.Disp label);PSstarted 1;EQ-REQ "psitemcomment" [ $(PsList) $(pg) $(curritem) $(Kp2.Disp label) ]
symbol	psListType	0
macro	dokpPrestart	ne? "$(psListType)" "-1" doPsCheck $(psListType);eq? "$(psListType)" "-1" eq? $(nPsLists) 1 doPsCheck $(psLists); eq? "$(psListType)" "-1" ne? $(nPsLists) 1 PostChecklists
in	kpPrestart	INT_RPC	d	psListType $1;WinMgr after:1:dokpPrestart
in	doPsCheck	INT_RPC	d	PsList 0;ne? "$1" "-1" PsList $1;pg 0;addPgMenuItems;createPgMenu;PSRefresh;WinMgr window:$(PSVer)
macro	ChecklistMsg	eq? $(nPsLists) 1 doPsCheck $(psLists); ne? $(nPsLists) 1 Ok.OK label:"$(SelInitCLLbl)";ne? $(nPsLists) 1 Ok action:'Ok.OK label:OK;PostChecklists' label:"$(CfgOk)" post
#if #arch(pe)
macro	PostChecklists	foreach $(psLists); do BuildMenuItem \$2;Checklists item:"'$(exitstr)' Checklists unpost";Checklists post
#else
macro	PostChecklists	Checklists clear;foreach $(psLists); do BuildMenuItem \$2;clItem "'$(exitstr)' Checklists unpost";Checklists item:$(clItem);Checklists post
#endif
in      BuildMenuItem   INT_RPC d       clItem "'$(PrestartTitle.$1)' doPsCheck $1";Checklists item:$(clItem)
macro	CancelPS eq? $(PSstarted) 1 AskSendPS;eq? $(PSstarted) 0 WinMgr window:w0
/* originally AskSendPS would ask operator if they wanted to send partially completed
   prestart check when they cancel but this is not necessary since they can just 
   press the Send button
 */
macro	AskSendPS	WinMgr window:w0
/* Pre start labels */
/* symbol  cfgLbl.pre.1 "Pre-Start Check List" */
symbol  cfgLbl.pre.2 "General Comment"
symbol  cfgLbl.pre.3 "Page"
symbol  cfgLbl.pre.4 "Prev Page"
symbol  cfgLbl.pre.5 "Next Page"
symbol  cfgLbl.pre.6 "OK"
symbol  cfgLbl.pre.7 "Pass All"
symbol  cfgLbl.pre.8 "Enter\nComment"
symbol  cfgLbl.pre.9 "Send"
symbol  cfgLbl.pre.10 "Cancel"
/* symbol  actwin */
symbol  SelInitCLLbl    "Please select your\\ninitial checklist"
