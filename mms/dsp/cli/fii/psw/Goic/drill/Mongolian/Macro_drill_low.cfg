%!/psw/cpp

/*
 * * * * * * * * * * * * * * * * * * *
 *  DISPATCH Real-Time Firmware Module
 * Copyright (c) Modular Mining Systems, 1982-1995
 *               All Rights Reserved
 *  $RCSfile: Macro_drill_low.cfg,v $
 * $Revision: 1.1 $
 *   $Author: dcitron $
 *     $Date: 2011/12/23 21:26:43 $
 *    $State: Exp $
 *   Purpose: GOIC object configuration file.
 * * * * * * * * * * * * * * * * * * *
 */

symbol	kpaction

symbol	w0Labels $(cfgLbl.67)
symbol	kpLabel

macro	rpc.0	kpLogOn
macro	rpc.1	kpReady
macro	rpc.2	BitLowered;StartHole
macro	rpc.3	kpReady
macro	rpc.4	kpReady
macro	rpc.5	kpReady
macro	rpc.6	BitLowered;StartHole
macro	rpc.7	holder 0;EndHole
macro	rpc.8	BitLowered;StartHole
macro	rpc.9	kpReady

symbol	icon.0	logo
symbol	icon.1	down
symbol	icon.2	ready
symbol	icon.3	standby
symbol	icon.4	delay
symbol	icon.5	logo
symbol	icon.6	ready
symbol	icon.7	drilling
symbol	icon.8	moving
symbol	icon.9	delay

macro	showDrilling	ne? $(actwin) wDrilling WinMgr window:wDrilling

symbol	actAngle 0 
symbol	actBrg 0
symbol	tgtAngle 0
symbol	tgtBrg 0
symbol	dist 0

symbol	holeID
symbol	patID
symbol	material
symbol	rods 0

symbol	gpsStat	0
symbol	saveText
symbol	saveFont

symbol	depth 0.00
symbol	dispDepth 0.00
symbol	showMaxDepth 0

symbol	target 0.0
symbol	rate 0.0
symbol	bottom 0.00

/* the following macros make sure that a certain state is initialized in the correct
   manner. They run only when the state is changed via a KSTATE command
 */
macro	NewState	eq? $(state) 7 StateDrilling;\
			eq? $(state) 8 StateTramming

/* in the initial drilling state, dispatch sends the pattern and hole that it thinks the
 * drill is drilling. Whether it got this from the CGC itself (as a result of a "start hole"
 * action or from its database (e.g. after a powerup of the drill, etc) is irrelevant
 * the 'initAddRodState' is a client specific setting with a default of '0' which should
 * be set in the client drill/Macro.cfg as follows:
 *
 * '0' adding a rod has 2 stages 'start' and 'end'
 * '2' adding a rod is a one step process
 */

symbol	initAddRodState	0

#if #arch(pe)
	macro   StateDrilling 	w0act $(initAddRodState);setw0act;\
                                patID $(w0.v2 label);\
				holeID $(w0.v3 label);\
				showMain

	macro   StateTramming   w0.action map:no;\
                                patID $(w0.v2 label);\
                                holeID $(cfgLbl.3);\
                                holeOverride 0;\
                                DoAutoZoomOut

#else
	macro	StateDrilling	ComMgr hasBeenJackedUp:1;\
				hp.cb0 map:no;\
				w0act $(initAddRodState);setw0act;\
				patID $(w0.v2 label);\
				holeID $(w0.v3 label);\
				showMain

	macro	StateTramming	ComMgr hasBeenJackedUp:0;\
				hp.cb0 label:$(cfgLbl.97) action:ExtendJacks map:yes;\
				w0.action map:no;\
				patID $(w0.v2 label);\
				holeID "$(cfgLbl.3)";\
				holeOverride 0;\
				DoAutoZoomOut
#endif

/* the following macro causes the drill to send the actual hole depth at a fixed
 * interval to dispatch, only when the drill is drilling of course
 */
macro	SendDepth	eq? $(state) 7 EQ-REQ "depth" [ "$(+ $(depth) $(bottom))" ];\
			WinMgr after:120:SendDepth

/* Check that the operator's taken the elevation
 * prior to extending the jacks
 */
macro	CheckStartWindow	ne? "$(actwin)" "hp" holder 3

macro	InvalidStartWindow	WinMgr window:hp;\
				KDISP "$(cfgLbl.107)";\
				KBEEP 2

#if #arch(pe)
	macro   CheckHoleParams holder 0;\
                        	eq? "$(holeID)" "$(cfgLbl.3)" holder 2;\
                        	eq? "$(holeID)" None holder 2;\
                        	eq? "$(patID)" "$(cfgLbl.3)" holder 1
#else
	macro	CheckHoleParams	holder 0;\
				eq? "$(ComMgr eqmtGpsStatus)" "Ok" CheckStartWindow;\
				eq? "$(holeID)" "$(cfgLbl.3)" holder 2;\
				eq? "$(holeID)" "none" holder 2;\
				eq? "$(patID)" "$(cfgLbl.3)" holder 1
#endif

macro	IncompleteHoleData	WinMgr beep:300;\
				saveText "$(w0.v1 label)";\
				saveFont "$(w0.v1 font)";\
				w0.v1 font:Tiny label:"$(cfgLbl.88)";\
				WinMgr after:3:'w0.v1 label:"\$(saveText)" font:\$(saveFont)'


/* the generic cycle "events" for a drill are as follows
 *
 * start tramming	the jacks are off the ground and the operator starts moving the
 *			drill to another drill hole position
 *
 * extend jacks		drill stops tramming to new position and the operator is lowering
 *			the jacks to stabilize the drill to the final drilling position
 *
 * bit on ground	the operator has dropped the bit onto the ground and is about to
 *			start drilling
 *
 * start hole		the operator actually initiates the drilling
 *
 * add rod		optional event where an additional rod is added to the drill stem
 *
 * end hole		the drill stem has been retreived from the hole, the bit is secured
 *			on the deck.
 *
 * these are expressed as the following macros which can be initiated either automatically or manually
 * (the default is manual) and also be over-ridden by client defined macros. Just create a client
 * specific psw/Goic/drill/Macro.cfg which contains a "#include_next <Goic/drill/Mongolian/Macro.cfg> and
 * define in it whatever macros you want to over-ride:
 *
 * StartTram
 * ExtendJacks
 * BitLowered
 * StartHole
 * AddRod
 * EndHole
 *
 * in the generic (manual) activation of these macros, there are only 3 main actions by the operator:
 *
 * "Extend Jacks"	initiates ExtendJacks
 *
 * "Start Hole"		initiates BitLowered and StartHole
 *
 * "End Hole"		initiates EndHole and StartTram
 *
 */
macro	StartTram

#if ! #arch(pe)
	macro	ExtendJacks	ComMgr hasBeenJackedUp:1;\
				hp.cb0 label:$(cfgLbl.98) action:'BitLowered;StartHole' map:yes
#endif

/* even though an onboard drill system will give us the depth and the VSHAFT 0
 * rpc will tell it to zero this, we explicitly set our local depth and bottom
 * symbols to '0' just to ensure that nothing gets carried over from a previous
 * hole
 */
macro	BitLowered	VSHAFT 0;depth 0.00;bottom 0.00; holder 0

symbol	startingHole	0

#if #arch(pe)
	macro   StartHole       startingHole 1;\
                        	CheckHoleParams;\
                        	eq? $(holder) 0 ReallyStartHole;\
                        	eq? $(holder) 1 IncompleteHoleData;\
                        	eq? $(holder) 3 InvalidStartWindow;\
                        	eq? $(holder) 2 ChangeHole

	macro   ReallyStartHole startingHole 0;\
                        	EQ-REQ "start" [ "$(holeID)" "$(patID)" ];rods 0

#else
	macro	StartHole	startingHole 1;\
				eq? $(holeOverride) 0 ne? "$(ComMgr holeName)" "none" holeID $(ComMgr holeName);\
				eq? $(depthOverride) 0 target $(ComMgr tgtDepth);\
				CheckHoleParams;\
				eq? $(holder) 0 ReallyStartHole;\
				eq? $(holder) 1 IncompleteHoleData;\
				eq? $(holder) 3 InvalidStartWindow;\
				eq? $(holder) 2 ChangeHole

	macro	ReallyStartHole	startingHole 0;\
				EQ-REQ "start" [ "$(holeID)" "$(ComMgr actPosX)" "$(ComMgr actPosY)" "$(ComMgr actPosZ)" "$(ComMgr mastIncl)" "$(ComMgr trueHeading)" "$(ComMgr tgtDepth)" "$(patID)" ];rods 0
#endif

symbol	matlAction

/*
 * Check if the current hole depth and distance to bottom values
 * make sense before deciding whether to post the keypad for the
 * operator to enter the hole depth at end-of-hole
 *
 * First check if the depth is less than 1...
 */
macro   CheckDepth      eq? $(max $(depth) 1) 1 CheckBottom;\
			ne? $(max $(depth) 1) 1 holder 1

/*
 * If the depth is less than 1, check if the distance-to-bottom
 * is less than 1...if both of them are less than 1 then post
 * the keypad
 */
macro   CheckBottom    	eq? $(max $(bottom) 1) 1 GetDepth;\
			ne? $(max $(bottom) 1) 1 holder 1

macro	GetDepth	keypadAction kpSetDepth;WinMgr window:wKp2

macro	kpSetDepth	depth $(wKp2.D label);\
			eq? $(max $(depth) 1) $(depth) holder 1;\
			EndHole

macro	GetMaterial	matlAction CheckMaterial3;WinMgr after:1:'Matl post'

macro	CheckMaterial	eq? $(cfg.7) 0 holder 2;\
			eq? $(cfg.7) 1 CheckMaterial2;\
			eq? $(cfg.7) 2 GetMaterial

macro	CheckMaterial2	eq? "$(material)" "" GetMaterial;\
			ne? "$(material)" "" holder 2;

macro	CheckMaterial3	CheckMaterial2;EndHole

macro	EndHole		eq? $(holder) 0 CheckDepth;\
			eq? $(holder) 1 CheckMaterial;\
			eq? $(holder) 2 ReallyEndHole

macro	ReallyEndHole	EQ-REQ "end" [ "$(depth)" "$(bottom)" "$(material)"];VRATES -1

/*
 * add a little more smarts to the drill CP-SWITCH as it can be used to cycle the
 * drill through the drill cycle automatically
 */
in	CP-SWITCH	0x18a	b	eq? $1 1 WinMgr press:w0.Icon;\
					eq? $1 100 StartTram;\
					eq? $1 101 ExtendJacks;\
					eq? $1 102 BitLowered;\
					eq? $1 103 StartHole;\
					eq? $1 104 EndHole;\
					eq? $1 105 StartAddRod;\
					eq? $1 106 EndAddRod;\
					eq? $1 107 AddRod

message	msg.0	DISPATCH -д тавтай морил
message	msg.1	$(loc)-дээр доошоо
message	msg.2	$(loc)-дээр бэлэн
message	msg.3	$(loc)-дээр тyр горимд
message	msg.4	$(loc)-дээр саатсан
message	msg.5	$(loc)-дээр холбож уях
message	pressOk	Ok дар

macro	kpLogOn	kpaction 'LOGON \$(Kp.D label)';\
		Kp label:'$(cfgLbl.68)' post

macro	kpReady 	Ok label:Бэлэн action:READY post

/*
 * Toggle distance-to-bottom and rate information in the
 * center display box on w0
 */

symbol  bottomRate      0.0
symbol  rateState       0

#if defined(lgcgauges)
macro   DisplayBottom   SET-VALUES w0.dataLbl 0 0 [ $(cfgLbl.85) ];\
                        SET-VALUES wGauges.dataLbl 0 0 [ $(cfgLbl.85) ];\
                        w0.data1 geom:x:260:w:92:bw:2;\
                        wGauges.data1 geom:x:260:w:92:bw:2;\
                        WinMgr refresh

macro DisplayRate       SET-VALUES w0.dataLbl 0 0 [ $(cfgLbl.102) ];\
                        SET-VALUES wGauges.dataLbl 0 0 [ $(cfgLbl.102) ];\
                        w0.data1 geom:x:246:w:120:bw:2;\
                        wGauges.data1 geom:x:246:w:120:bw:2;\
                        WinMgr refresh
#else
macro   DisplayBottom   SET-VALUES w0.dataLbl 0 0 [ $(cfgLbl.85) ];\
                        w0.data1 geom:x:260:w:92:bw:2;\
                        WinMgr refresh

macro   DisplayRate     SET-VALUES w0.dataLbl 0 0 [ $(cfgLbl.102) ];\
                        w0.data1 geom:x:246:w:120:bw:2;\
                        WinMgr refresh
#endif


macro   CheckBottomState        ne? $(rateState) 0 DisplayBottom;\
                                bottomRate $(bottom);\
                                rateState 0

macro   CheckRateState          ne? $(rateState) 1 DisplayRate;\
                                bottomRate $(rate);\
                                rateState 1

macro	SetDisplayDepth	eq? $(max $(dispDepth) $(depth)) $(depth) dispDepth $(depth)

/*
 * Incoming depth, rate and distance-to-bottom data
 *
 * Toggle between displaying distance-to-bottom and rate information
 * using a buffer to prevent constant screen flicker due to "bouncing"
 * of the distance-to-bottom value. Only switch from rate to bottom
 * when bottom value is greater than 0.5 mine units. Only switch back
 * when bottom value is less than 0.2 mine units
 */
macro   getKdrill       depth $1;rate $2;bottom $3;\
 			eq? $(showMaxDepth) 1 SetDisplayDepth;\
			ne? $(showMaxDepth) 1 dispDepth $1;\
                        eq? $(max $(bottom) 0.5 ) $(bottom) CheckBottomState;\
                        eq? $(min $(bottom) 0.2 ) $(bottom) CheckRateState

/*
 * Numeric value representing the component type
 * as defined by the position in cfgLbl.77 string
 */
symbol	compType

/*
 * Part number being mounted on the drill
 */
symbol	compID

/* 
 * Reason for dismounting the old part - numeric (gets
 * matched up on the workstation)
 */
symbol	dReason
symbol	keypadAction

macro	MountCompKeypad	keypadAction SetCompID;\
			SetKeypadLabel;\
			WinMgr window:wKp

/*
 * Set the compID value if the input is via the keypad
 */
macro	SetCompID	compID $(wKp.DI label);Dismount post

/*
 * Send the component change to Dispatch
 */
macro	SendComp	EQ-REQ "part" [ "$(compType)" "$(compID)" "$(dReason)" "$(+ $(depth) $(bottom))" ]

symbol	partToggle -1 
symbol	setPartToggle 1

macro	UpdatePartGeometry	wDrilling.part5 geom:x:150:y:170:h:40:w:150:bw:2;\
				wDrilling.pb5 geom:x:14:y:170:h:40:w:126:bw:2;\
				wDrilling.prtToggle map:y

macro	TogglePartDisplay	eq? $(partToggle) $(/ $(- $1 $(% $1 5)) 5) wDrilling.part$1 map:y;\
				eq? $(partToggle) $(/ $(- $1 $(% $1 5)) 5) wDrilling.pb$1 map:y;\
				ne? $(partToggle) $(/ $(- $1 $(% $1 5)) 5) wDrilling.part$1 map:n;\
				ne? $(partToggle) $(/ $(- $1 $(% $1 5)) 5) wDrilling.pb$1 map:n

macro	SetPartToggleFlag	eq? $(partToggle) -1 partToggle 0;\
				eq? $(partToggle) 0 holder 1;\
				eq? $(partToggle) 1 holder 0;\
				eq? $(setPartToggle) 1 partToggle $(holder)

macro	CheckPartDisplay	eq? $(partToggle) -1 partToggle 0;\
				foreach $(cfgLbl.77);do TogglePartDisplay


symbol	partCount -1

macro	CheckPartCount	partCount 0;\
			foreach $(cfgLbl.77);do partCount \$(+ \$(partCount) 1);\
                        ne? $(min $(partCount) 6) $(partCount) UpdatePartGeometry;\
                        ne? $(min $(partCount) 6) $(partCount) wDrilling.prtToggle map:y;\
                        ne? $(min $(partCount) 6) $(partCount) CheckPartDisplay

/* Configure labels for components and pattern data 
 * For each label value found in the various configuration symbols
 * map to the corresponding object label on the screen
 * (see Macro_cfg.cfg and look up the cfgLbl. value to see what
 * specifically will be displayed)
 */


macro 	InitDrillWindow	ne? "$(keypadAction)" "SetCompID" SET-VALUES wDrilling.pb 0 0 [ $(cfgLbl.77) ];\
			SET-VALUES wDrilling.cb 0 0 [ $(cfgLbl.79) ];\
			SET-VALUES wDrilling.lbl 0 0 [ $(cfgLbl.75) ];\
   			wDrilling.prtToggle label:"$(cfgLbl.99)";\
			eq? $(partCount) -1 CheckPartCount;\
			eq? "$(wDrilling.part0 label)" "" SET-VALUES wDrilling.part 0 0 [ $(cfgLbl.78) ];\
			startingHole 0

macro	InitInfoWindow	SET-VALUES wInfo.lbl 0 0 [ $(cfgLbl.104) ];\
			wInfo.update label:$(cfgLbl.106)

macro	UpdateReason	WinMgr window:wDrilling;\
			SendComp

/*
 * The wKp window is used for entering component IDs as well
 * as changing the pattern or hole number. Make sure the title
 * for the window matches the desired input
 */
macro	SetKeypadLabel	eq? "$(keypadAction)" "SetHoleID"	wKp.lbl0 label:"$(cfgLbl.70)";\
			eq? "$(keypadAction)" "SetPattern"	wKp.lbl0 label:"$(cfgLbl.86)";\
			eq? "$(keypadAction)" "SetCompID"	wKp.lbl0 label:"$(cfgLbl.73)";\
			eq? "$(keypadAction)" "SetCompID"	wKp.lblSel0 label:"$(wDrilling.pb$(- $(compType) 1) label)" map:y;\
			eq? "$(keypadAction)" "SetMastAngle"	wKp2.lbl0 label:"$(cfgLbl.92)";\
			eq? "$(keypadAction)" "kpSetDepth"	wKp2.lbl0 label:"$(cfgLbl.87)";\

symbol	msgObject
symbol	lblValue

/* Post a short message up for 3 seconds in some target object */
macro	ShortMessage	WinMgr beep:300;\
 			saveText "$($(msgObject) label)";\
			saveFont "$($(msgObject) font)";\
			$(msgObject) label:"$(cfgLbl.$(lblValue))";\
			WinMgr after:3:'$(msgObject) label:"$(saveText);$(msgObject) font:$(saveFont)'

/*
 * If the operator overrides the current hole then
 * don't let the ComMgr update it until an
 * ENDHOLE RPC has been generated
 */
symbol	holeOverride 0

/*
 * ditto with target depth
 */
symbol	depthOverride 0

/*
 * Check that the pattern's set before allowing the
 * operator to request a new hole or change the current
 * hole
 */
macro	CheckPattern	holder 0;\
			foreach $(cfgLbl.80);do eq? "\$(wDrilling.info0 label)" \$2 holder 1;\
			eq? $(holder) 1 IncompletePattern;\
			ne? $(holder) 1 $(nextAction)

macro	ChangeHole	keypadAction SetHoleID;\
			WinMgr window:wKp
/*
 * Set the hole ID based on operator input
 */
macro	SetHoleID	ne? "$(wKp.DI label)" "" holeID "$(wKp.DI label)";\
			ne? "$(wKp.DI label)" "" holeOverride 1;\
                        ne? "$(wKp.DI label)" "" DoStartingHole

macro	DoStartingHole	eq? $(startingHole) 1 StartHole

/*
 * Set the target depth based on operator input
 */
macro	SetTargetDepth	target $(wKp.DI label);\
			depthOverride 1

/*
 * Set the current pattern based on operator input
 */
macro	SetPattern	ne? $(state) 7 patID "$(wKp.DI label)";\
			ne? $(state) 7 EQ-REQ "pattern" [ "$(patID)" ];\
			eq? $(state) 7 lblValue 91;\
			eq? $(state) 7 msgObject wDrilling.lbl1;\
			eq? $(state) 7 ShortMessage

/* Post a brief message if there's no pattern
 * set in the patID symbol and the operator
 * tries to start a hole
 */
macro	IncompletePattern	WinMgr beep:300;\
				wDrilling.lbl1 label "$(cfgLbl.74)";\
				WinMgr after:2:InitDrillWindow

/* Request an extra hole number to be generated
 * by the central computer - this will be sent back
 * in the form of setting holeID to the new value
 */
macro	NewHole		EQ-REQ "newhole" [ "0" ]

/* Initialise the hole and pattern to "None" or the
 * local language equivalent so the CheckHoleParams
 * macro functions correctly - this is called by the
 * WinMgr object
 */
macro	InitPatternParams	holeID "$(cfgLbl.3)";patID "$(cfgLbl.3)"

macro	DrillInitialise	Initw0Window;\
			InitDrillWindow;\
			InitPatternParams

#if #arch(pe)
	macro   SetMastAngle    wDrilling.v1 write:"$(cfgLbl.96)\n";\
				actAngle $(wKp2.D label)
#else
	macro	SetMastAngle	ComMgr mastIncl:$(wKp2.D label);\
				actAngle $(ComMgr mastIncl);\
				wDrilling.v1 write:"$(cfgLbl.96)\n"
#endif

/*  commented out to get mastangle to work

macro	SetMastAngle	actAngle "$(wKp2.D label)"

 */

/* Allows the operator to change his/her mind if
 * they've specified a different hole to that 
 * indicated by the GPS system
 *
 * "AUTO" line moved to the end since mastIncl was not getting set properly before
 */

#if #arch(pe)
	macro   RestoreFullAuto holeOverride 0;\
                        	depthOverride 0;\
                        	wDrilling.v1 write:"$(cfgLbl.94)\n";\
                        	wDrilling.v1 write:"$(cfgLbl.95)\n";\
#else
	macro	RestoreFullAuto	holeOverride 0;\
				depthOverride 0;\
				wDrilling.v1 write:"$(cfgLbl.94)\n";\
				wDrilling.v1 write:"$(cfgLbl.95)\n";\
                        	ComMgr mastIncl:"AUTO"
#endif

/* The following macros are for language-independence. If a different
 * language is required then the cfgLbl values should be changed in
 * Goic/Mongolian/Macro_cfg.cfg
 */

/* Set up the labels on the hp window */
macro   InitHpWindow    SET-VALUES hp.dataLbl 0 0 [ $(cfgLbl.76) ];\
                        SET-VALUES hp.statusLbl 0 0 [ $(cfgLbl.83) ];\
                        SET-VALUES hp.dispLbl 0 0 [ $(cfgLbl.84) ];\
			ne? $(autoZoomOn) 1 hp.CADCanvas zoom:$(actZoom)

/* Set up the labels on the w0 window */
macro   Initw0Window    eq? $(rateState) 0 SET-VALUES w0.dataLbl 0 0 [ $(cfgLbl.85) ];\
                        ne? $(rateState) 0 SET-VALUES w0.dataLbl 0 0 [ $(cfgLbl.102) ]

/* symbols related to the w0 action button normally used to add rods */

symbol	w0act	0

macro	w0action.0	StartAddRod
macro	w0action.1	EndAddRod
macro	w0action.2	AddRod
macro	w0action.3	AddRodLength

macro	setw0act	eq? $(w0act) 1 w0.action map:yes colors:statusBad label:$(cfgLbl.101);\
			ne? $(w0act) 1 w0.action map:yes colors:normal label:$(cfgLbl.100)

macro	StartAddRod	w0act 1;VSHAFT 1;setw0act
macro	EndAddRod	w0act 0;VSHAFT 2;IncrementRodCount;setw0act
macro	AddRod		w0act 3;VSHAFT 3;IncrementRodCount;setw0act
macro	AddRodLength	w0act 4;VSHAFT $1;IncrementRodCount;setw0act

macro	IncrementRodCount	rods $(+ $(rods) 1)

/* CheckHoleDist
 *
 * Check that there is a valid distance-to-target value before
 * zooming in
 */
macro	CheckHoleDist	ne? $(max $(dist) 0) 0 DoAutoZoomIn;\
			eq? $(max $(dist) 0) 0 DoAutoZoomOut

/*
 * Compare the distance to target with the minimum zoom distance (cfg.6 value) and
 * call the zoom in or zoom out process as appropriate
 */
macro   CheckAutoZoom   eq? $(max $(cfg.6) $(dist)) $(cfg.6) CheckHoleDist;\
                        ne? $(max $(cfg.6) $(dist)) $(cfg.6) DoAutoZoomOut

/*
 * Zoom in to the max zoom level if not already zoomed in. Save the current
 * zoom level first so it can be restored when either the hole is drilled
 * or the drill moves outside the minimum autozoom radius
 */
macro	DoAutoZoomIn	ne? $(autoZoomOn) 1 hp.CADCanvas zoom:$(maxZoom);\
			ne? $(autoZoomOn) 1 autoZoomOn 1

/*   
 * Restore the zoom level to the pre-auto-zoom setting
 */
macro	DoAutoZoomOut	eq? $(autoZoomOn) 1 hp.CADCanvas zoom:$(actZoom);\
                        eq? $(autoZoomOn) 1 autoZoomOn 0

/*
 * The following is used to make sure that the correct configuration is
 * set for the Pattern (or local equivalent) wDrilling.cb0 button - every
 * time the window posts the downloadCfgSet symbols is checked and if zero
 * a request to configure the button's action is sent to the data monitor
 */

symbol  downloadCfgSet 0

macro   SetPatternButtonToList  wDrilling.cb0 action:'Pattern post';\
                                downloadCfgSet 1

macro   SetPatternButtonToReq   wDrilling.cb0 action:'EQ-REQ pattern [ nil ]';\
                                downloadCfgSet 1

macro   CheckPatternConfig      eq? $(downloadCfgSet) 0 EQ-REQ "config" [ nil ]

/*
 * Initialisation macro for the wDrilling screen
 */

macro CheckDrillWindowItems     CheckPartDisplay;\
                                CheckPatternConfig;\
                                CheckScreenUpdate

#if ! #arch(pe)
	macro	CancelComMgrHole	ComMgr cancelLastHole;\
					StateTramming

macro	ConfirmRedrill	operResponse 0;\
			WinMgr window:w0;\
			nextAction "EQ-REQ confirm";\
			cancelAction "CancelComMgrHole";\
			yesNo label:'$(cfgLbl.108) $(holeID)' post

/* 
 * DoMessageIn macro edited here (from common/Macro_msg.cfg) to only
 * affect HPdrill code. All other HP code will be adjusted later
 */
macro	DoMessageIn	KBEEP 1;w0.Text write:"$(cfgLbl.9) $(cfgLbl.11) $2:\n";w0.Text write:$1\n
macro   SendMessage     MESSAGE "$(Kp2.Disp label)"
symbol lowdrill
macro   showHP lowdrill 1
#endif
