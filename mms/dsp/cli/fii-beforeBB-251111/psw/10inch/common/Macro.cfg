#!/psw/cpp
/*
 * * * * * * * * * * * * * * * * * * *
 *  DISPATCH Real-Time Firmware Module
 * Copyright (c) Modular Mining Systems, 1982-2011
 *               All Rights Reserved
 *  $RCSfile: Macro.cfg,v $
 * $Revision: 1.123 $
 *   $Author: olivas $
 *     $Date: 2020/02/27 17:05:25 $
 *    $State: Exp $
 * * * * * * * * * * * * * * * * * * *
 */

/* internal RPCs can have the same hex number */
#define INT_RPC	0xa000

#include <10inch/common/Rpc.cfg>

/* Define Version specific items */
#if defined DEMAINT
#define PERSISTSUPPORT	yes
symbol	persist_support	PY
#else
symbol	persist_support	PN
#endif

/* CLASS definition in case this information is needed by Macro code */
message	ClassType	CTYPE

/* layers used for PostWindow */
#define	BASE_LAYER	0
#define SCREEN_LAYER	1
#define MENU_LAYER	2
#define	ERROR_LAYER	3

/* default UNIT enum values if client's Central.cfg doesn't define them */
message	u01	Truck
message	u02	Shovel
message	u03	Dump
message	u04	Crusher
message	u05	Stockpile
message	u06	Blast
message	u07	Workshop
message	u08	Shiftchange
message	u09	Call Point
message	u10	Pit
message	u11	Region
message	u12	Drill
message	u13	Dozer
message	u14	Grader
message	u15	Wheel Dozer
message	u16	Aux Crusher
message	u17	Foreman
message	u18	Water Truck
message	u19	Utility Vehicle
message	u20	Man Bus
message	u21	Generic Auxil

/* Helper functions */
message	nil
symbol	n
symbol	defaultValue
symbol	break
macro	ForDo	$3;ForNext $(+ $1 1) $2 "$3"
in	ForNext	INT_RPC	dds	eq? $1 $2 break 1;eq? $(break) 0 ForDo
in	For	INT_RPC	ds	break 0;ForNext 0 $1 $2
symbol	postedWindows
symbol	newWindows
symbol	winName
macro	AddWindow4	$(winName) map:y;newWindows $(newWindows) $(winName) $1
in	AddWindow3	INT_RPC	ds	ne? $2 $(winName) AddWindow4
in	AddWindow2	INT_RPC	dds	eq? $1 $(max $1 $(+ $2 1)) AddWindow3 $1 $3
in	AddWindow1	INT_RPC	dds	ne? $1 $(max $1 $(+ $2 1)) AddWindow3 $1 $3
in	AddWindow0	INT_RPC	s?ds	winName $1
in	AddWindow	INT_RPC	ddsds	AddWindow$(* $(% $1 2) $2) $3 $4 $5
/*
 * PostWindow(str win_name, int layer = 0): Posts a window with a given layer.
 * UnpostWindow(str win_name): Unposts a window previously posted by PostWindow.
 * Whenever a window is posted using PostWindow, all windows previously called
 * with this method will repost in order of layer from lowest to highest.  This
 * causes the windows to layer themselves according to the values provided.
 * UnpostWindow must be used to unpost windows posted with PostWindow
 */
in	PostWindow	INT_RPC	s?d	newWindows $(nil);defaultValue $2;eq? "$(defaultValue)" " " defaultValue BASE_LAYER;foreach $(postedWindows);do AddWindow \$1 1 \$2 $(defaultValue) $1;AddWindow0 "$1";AddWindow3 $(defaultValue) "";foreach $(postedWindows);do AddWindow \$1 2 \$2 $(defaultValue) $1;postedWindows $(newWindows)
macro	RemoveWindow1	eq? $(n) 0 newWindows $(newWindows) $2; n 0
in	RemoveWindow	INT_RPC	ss	eq? $1 $2 n 1;ne? $1 $2 RemoveWindow1
in	UnpostWindow	INT_RPC	s	$1 map:n;newWindows $(nil);n 0;foreach $(postedWindows);do RemoveWindow $1 \$2;postedWindows $(newWindows)

/* Emergency Flash */
symbol  doEmrgFlash	0
macro   EmrgFlash       doLastColor;eq? $(doEmrgFlash) 1 WinMgr after:1:EmrgFlash2
macro   EmrgFlash2      eq? $(doEmrgFlash) 1 doRed; WinMgr after:1:EmrgFlash

/* MsgBox */
symbol	msgBoxAction
symbol	msgBoxAction2
macro	MsgBoxOk	MsgBox.Ok map:y;MsgBox.Btn1 map:n;MsgBox.Btn2 map:n
macro	MsgBoxYesNo	MsgBox.Ok map:n;MsgBox.Btn1 label:"$(YesLbl)" action:doMsgBoxYes map:y;MsgBox.Btn2 label:"$(NoLbl)" action:doMsgBoxNo map:y
macro	MsgBox2Btn	msgBoxAction2 $7;MsgBox.Ok map:n;MsgBox.Btn1 label:"$5" action:doMsgBoxBtn1 map:y;MsgBox.Btn2 label:"$6" action:doMsgBoxBtn2 map:y
in	MessageBox	INT_RPC	s?ssssss	doEmrgFlash 0;\
						MsgBox.Label label:"$1";\
						MsgBox.Title label:"";\
						MsgBox.Title label:"$2";\
						msgBoxAction $3;\
						defaultValue $4;\
						eq? "$(defaultValue)" " " defaultValue Ok;\
						MsgBox$(defaultValue);\
						PostWindow "MsgBox" ERROR_LAYER
macro	doMsgBoxClose	UnpostWindow "MsgBox"; doEmrgFlash 0
macro	doMsgBoxOk	$(msgBoxAction);doMsgBoxClose
macro	doMsgBoxYes	doMsgBoxOk
macro	doMsgBoxNo	doMsgBoxClose
macro	doMsgBoxBtn1	doMsgBoxOk
macro	doMsgBoxBtn2	$(msgBoxAction2);doMsgBoxClose

/* Quick Message logic */
#if !defined DELITE && DEMAJOR >= 6 && DEMAINT >= 3
symbol	quickmesg_support QMY
#else
symbol	quickmesg_support QMN
#endif
#define QMFILE	<10inch/common/QuickMessage.cfg>
#include QMFILE

/* Weight Station Support */
macro	WeightMsg	MessageBox "$(ReadyToWeighLbl)" "" "EQ-REQ reqweight" "2Btn" "$(OkLbl)" "$(CancelLbl)" "doMsgBoxClose"

/* Trucks En Route Info */
macro doTrkRoutes     ClearTrans;postTrans "$(msg.trkrt)";EQ-REQ "TrkEnroute"

/* Communications functions */
/* Include Enhanced PowerUp logic */
#define  PWRUPFILE <10inch/common/PwrUp.cfg>
#include PWRUPFILE

symbol	doCommCheck	1
symbol	commstat unknown
/* the following symbols can be overriden in client Central.cfg */
symbol	noCommsTime	5
symbol	doCommsBeep	0
macro	doGoodComms	showGoodComms;eq? $(doCommsBeep) 1 goodCommsInf;
macro	goodCommsInf	KBEEP 1;postTrans "$(GoodCommsLbl)"
macro	doBadComms	showBadComms;eq? $(doCommsBeep) 1 badCommsInf;
macro	badCommsInf	KBEEP 1;postTrans "$(BadCommsLbl)"
macro  switchcomms    commstat $(OMS connected);\
                      eq? $(commstat) yes doGoodComms;\
                      ne? $(commstat) yes doBadComms;
macro  checkcomms     eq? $(doCommCheck) 1 ne? $(OMS connected) $(commstat) switchcomms
macro  startcomms      commstat $(OMS connected);\
                      eq? $(commstat) yes showGoodComms;\
                      ne? $(commstat) yes showBadComms;\
                      WinMgr after:5:checkcomms;
macro	doComm	doCommsBeep 1;MessageBox "$(CommsBeepLbl)" "$(ConfirmActLbl)" "setDoBeep" "YesNo"
macro	setDoBeep	doCommsBeep 0
macro   commsClose	doMsgBoxClose
macro	noTalk		MessageBox "$(CantSendLbl)" "$(CommsErrorLbl)";ne? $(noCommsTime) 0 WinMgr after:$(noCommsTime):commsClose
#ifdef DELITE
	macro showGoodComms     StatBar.Comm icon:wifi_on
	macro showBadComms StatBar.Comm icon:wifi_off
	macro	InitComms	Vsms every:5000:checkcomms
#else
/*  Comms icon not supported in embedded version 6.2 */
#	ifdef VSIXTWO
		macro	InitComms	doCommCheck 0
		macro	noTalk		MessageBox "$(CantSendLbl)" "$(CommsErrorLbl)"
#	else
		macro	showGoodComms	UpdateStatBarImg "4" "wifi_on"
		macro	showBadComms	UpdateStatBarImg "4" "wifi_off"
		macro	InitComms	InfoPanel addColumn:4,1;\
					InfoPanel addObject:4,Comm,Small,White,Center;\
					KMENU2 Options [ '"$(CommsBeepBtn)" doComm' ];\
					Vsms every:5000:checkcomms
#	endif
#endif
symbol	curWindow
macro	postTrans1	w0.Text write:"$1\n";WinMgr beep:1;ne? "$(curWindow)" " " AlertTrans
in	postTrans	INT_RPC s	ne? "$1" "" postTrans1
macro	ClearTrans	w0.Text clear
symbol	fmtdate
symbol  DateFmt	dmy	/* supported values are dmy, mdy, and ymd */
symbol 	DateSeparator	/
in	FormatDate	INT_RPC ?s,s	fmtdate "Invalid DateFmt";\
					eq? $(DateFmt) mdy fmtdate "$(Time month)$(DateSeparator)$(Time day)$(DateSeparator)$(Time year) ($(Time get))";\
					eq? $(DateFmt) dmy fmtdate "$(Time day)$(DateSeparator)$(Time month)$(DateSeparator)$(Time year) ($(Time get))";\
					eq? $(DateFmt) ymd fmtdate "$(Time year)$(DateSeparator)$(Time month)$(DateSeparator)$(Time day) ($(Time get))";\
					return $(fmtdate)

/* Keyboard */
symbol	MsgMaxLen	64
symbol	dfltKPLen	60
/* a new method, maxLength, was added to Keyboard control in build 1.4.26 (6.3.26)
 * since this method is not on older builds we have added special code that will 
 * determine this and not try to set maxLength on older versions. Hopefully
 * someday this code can be removed when all deployed field units are running this
 * build or newer.
 */
symbol  maxLenSupport	0
symbol  kbtmparg
symbol  retval
symbol	kbopen		n
macro	InitKeyboard	eq? $(max $(Keyboard maxLength) 100) 100 maxLenSupport 1
#ifdef NEWUI
	in	GetPadValue	INT_RPC	?s,s	return "$(Keyboard text)"
	in	GetPadValue2	INT_RPC	?s,s	retval "$(nil)";ne? "$(Keyboard text)" " " retval "$(Keyboard text)";return $(retval)
	macro	ResetMaxLength	eq? $(maxLenSupport) 1 Keyboard maxLength:0
	macro	SetMaxLength	eq? $(maxLenSupport) 1 Keyboard maxLength:$(kbtmparg)
	macro	PostPad		kbtmparg $3;eq? "$(kbtmparg)" " " kbtmparg 0;Keyboard label:$1;Keyboard macro:$2;SetMaxLength;defaultValue "$4";Keyboard text:"$(defaultValue)";Keyboard show; kbopen y;Keyboard noneMacro:$5 cancelMacro:$6
	macro	PostKeyPad1	Keyboard keyCode:ABC;ResetMaxLength;PostPad
	macro	PostNumPad1	Keyboard keyCode:12;ResetMaxLength;PostPad
	macro	PostNoneNumPad1	Keyboard keyCode:12N;ResetMaxLength;PostPad
	macro	PostNumPad1	Keyboard keyCode:12;ResetMaxLength;PostPad
	macro	PostNegNumPad1	Keyboard keyCode:-12;ResetMaxLength;PostPad
	macro	PostDotNumPad1	Keyboard keyCode:.12;ResetMaxLength;PostPad
	macro	PostAlphaNumPad1	Keyboard keyCode:12ABC;ResetMaxLength;PostPad
#else
	/* placeholder code for potential ML support */
	symbol	lastPad
	in	GetPadValue	INT_RPC	?s,s	return "$($(lastPad).Value label)"
	in	GetPadValue2	INT_RPC	?s,s	return "$($(lastPad).Value label)"
	in	PostPad		INT_RPC	sss	$3.Title label:$1;$3.Value label:"$(defaultValue)";lastPad $3;$3 onunpost:$2;$3 post
	macro	PostKeyPad1	PostPad $1 $2 KeyPad
	macro	PostNumPad1	PostPad $1 $2 NumPad
	macro	PostNegNumPad	PostPad $1 $2 NumPad
	macro	PostDotNumPad	PostPad $1 $2 NumPad
#endif
in	PostKeyPad	INT_RPC	ss?dss	PostKeyPad1
in	PostNumPad	INT_RPC	ss?dss	PostNumPad1
in	PostNoneNumPad	INT_RPC	ss?dss	PostNoneNumPad1
in	PostNegNumPad	INT_RPC	ss?dss	PostNegNumPad1
in	PostDotNumPad	INT_RPC ss?dss	PostDotNumPad1
in	PostAlphaNumPad	INT_RPC	ss?dss	PostAlphaNumPad1

/* RPC Macros */
macro	sendUp		sendto up
macro	sendBcast	sendto broadcast
macro	doAssign	sendUp
macro	doArrive	sendUp
macro	doLoad		sendUp
macro	doLogon		sendUp;SendQMUpdate$(quickmesg_support)
macro	doFuel		sendUp
macro	doHelp		sendUp
macro	doDelay		sendUp
macro	doDown		sendUp
macro	doReady		sendUp
macro	doStandby	sendUp
macro	doRecall	sendUp
macro	doDefect	sendUp
macro	doSelfAsn	sendUp
macro	doFull		sendUp
macro	doMessage	sendUp
macro	doEqReq		sendUp
macro	doPrestart	sendUp
macro	doPanfull	sendUp
macro	doNoOk		sendUp
macro	doPwrUp		sendUp
macro	doReqMenu	sendUp
macro	doReptReq	sendUp
macro	sendKbcst	sendBcast
macro   doKbcst		eq? $(myEmerg) n handleKbcst;eq? $(myEmerg) y myEmerg n
macro	handleKbcst	eq? "$2" "$(ClassType)" showKbcst;eq? "$2" "all" showKbcst;eq? "$2" "field" showKbcst
macro	showKbcst	postTrans $3;KBEEP $1
symbol	GotAck
macro	beepOn		eq? $(GotAck) 0 WinMgr beep:-1
macro	beepOff		WinMgr beep:0
macro	AckOk		GotAck 1;WinMgr cancel:AckIgnore cancel:beepOn;beepOff
macro	AckIgnore	doMsgBoxClose;NOOK;beepOff
macro	doKack		doKack$(tbt_support)
macro	doKdack		KACK 5 "$1"
macro	doKask		eq? "$3" "EXQRY" SetExQry;eq? "$2" "Kp" PostNumPad "$1" $4;do_kask_extra
macro	doKaudio	WinMgr audio:$1
macro	doKmenu		$1 items:$2
macro	doKmenu2	foreach $2;do $1 item:\$2
macro	doKmenclr	foreach $3;do $1 itemColor:\$3:$2
macro	doKcolor	$1 itemColor:$2:$3
macro	doKmatl		""
macro	doKbeep		WinMgr beep:$(* $1 1000) /* changed this, is this ok (negative values)? */
macro	doKdisp		doKdisp$(tbt_support)
macro	doKtable	$1.title label:"$2";foreach $3;do $1.t\$1 label:"\$2"
macro	doKtable2	$1.title label:"$2";tbl_win $1;tbl_offset $3;foreach $4;do ktbl_pop
macro   ktbl_pop	$(tbl_win).t$(+ $(tbl_offset) $1) label:"$2"
macro	doCpSwitch	eq? $1 1 WinMgr press:w0.NextAct
macro	doMayday	doMayday$(tbt_support)

/* Gps Tag Act macros */
#ifdef GPSTAGACT
#if DEMAJOR >= 6 && DEMINOR >= 6 && DEMAINT < 8										   
macro   doDown          EQ-REQ "gpstagact" [ "1" "$1" "" "$(GpsTruck x)" "$(GpsTruck y)"\
                        "$(GpsTruck z)" "$(GpsTruck velocity)" "$(GpsTruck status)" ]
macro   doReady         EQ-REQ "gpstagact" [ "2" "$1" "" "$(GpsTruck x)" "$(GpsTruck y)"\
                        "$(GpsTruck z)" "$(GpsTruck velocity)" "$(GpsTruck status)" ]
macro   doStandby       EQ-REQ "gpstagact" [ "3" "$1" "" "$(GpsTruck x)" "$(GpsTruck y)"\
                        "$(GpsTruck z)" "$(GpsTruck velocity)" "$(GpsTruck status)" ]
macro   doDelay         EQ-REQ "gpstagact" [ "4" "$1" "" "$(GpsTruck x)" "$(GpsTruck y)"\
                        "$(GpsTruck z)" "$(GpsTruck velocity)" "$(GpsTruck status)" ]
#endif
#if DEMAJOR >= 6 && ((DEMINOR >= 6 && DEMAINT >= 8) || DEMINOR >= 7)
macro   doAssign        sendUp
macro   doArrive        sendUp
macro   doLoad          sendUp
macro   doFull          sendUp
#elif DEMAJOR >= 6 && DEMINOR >= 6 && DEMAINT >= 3							  
macro   doAssign        EQ-REQ "gpstagact" [ "5" "$1" "" "$(GpsTruck x)" "$(GpsTruck y)"\
                        "$(GpsTruck z)" "$(GpsTruck velocity)" "$(GpsTruck status)" \"$(Time epoch)\" ]
macro   doArrive        EQ-REQ "gpstagact" [ "6" "$1" "" "$(GpsTruck x)" "$(GpsTruck y)"\
                        "$(GpsTruck z)" "$(GpsTruck velocity)" "$(GpsTruck status)" \"$(Time epoch)\" ]
macro   doLoad          EQ-REQ "gpstagact" [ "7" "$1" "" "$(GpsTruck x)" "$(GpsTruck y)"\
                        "$(GpsTruck z)" "$(GpsTruck velocity)" "$(GpsTruck status)" \"$(Time epoch)\" ]
macro   doFull          EQ-REQ "gpstagact" [ "12" "$1" $2 "$(GpsTruck x)" "$(GpsTruck y)"\
                        "$(GpsTruck z)" "$(GpsTruck velocity)" "$(GpsTruck status)" \"$(Time epoch)\" ]
#else
macro   doAssign        EQ-REQ "gpstagact" [ "5" "$1" "" "$(GpsTruck x)" "$(GpsTruck y)"\
                        "$(GpsTruck z)" "$(GpsTruck velocity)" "$(GpsTruck status)" ]
macro   doArrive        EQ-REQ "gpstagact" [ "6" "$1" "" "$(GpsTruck x)" "$(GpsTruck y)"\
                        "$(GpsTruck z)" "$(GpsTruck velocity)" "$(GpsTruck status)" ]
macro   doLoad          EQ-REQ "gpstagact" [ "7" "$1" "" "$(GpsTruck x)" "$(GpsTruck y)"\
                        "$(GpsTruck z)" "$(GpsTruck velocity)" "$(GpsTruck status)" ]
macro   doFull          EQ-REQ "gpstagact" [ "12" "$1" $2 "$(GpsTruck x)" "$(GpsTruck y)"\
                        "$(GpsTruck z)" "$(GpsTruck velocity)" "$(GpsTruck status)" ]
#endif
#endif
/*
 * define symbols and  macros for extra stuff that is done for standard rpcs
 * that can be defined for load options
 */
symbol	kstate_extra
symbol	kdisp_extra
symbol	kack_extra
symbol	kask_extra
symbol	kbeep_extra
symbol	rpc_arg1
symbol	rpc_arg2
symbol	rpc_arg3
symbol	rpc_arg4
symbol	rpc_arg5
symbol	rpc_arg6
symbol	rpc_arg7
symbol	rpc_arg8
symbol	rpc_arg9
symbol	rpc_arg10
symbol	tbl_win
symbol	tbl_offset
macro	do_kstate_extra		save_kstate_args;foreach $(kstate_extra);do \$2.kstate_extra
macro	save_kstate_args	rpc_arg1 $1;rpc_arg2 $2;rpc_arg3 $3;rpc_arg4 $4;rpc_arg5 $5;rpc_arg6 $6;rpc_arg7 $7
macro	do_kdisp_extra		save_kdisp_args;foreach $(kdisp_extra);do \$2.kdisp_extra
macro	save_kdisp_args		rpc_arg1 $1
macro	do_kack_extra		save_kack_args;foreach $(kack_extra);do \$2.kask_extra
macro	save_kack_args		rpc_arg1 $1;rpc_arg2 $2
macro	do_kask_extra		save_kask_args;foreach $(kask_extra);do \$2.kack_extra
macro	save_kask_args		rpc_arg1 $1;rpc_arg2 $2;rpc_arg3 $3;rpc_arg4 $4

/* KSTATE & KSTATE2 macros */
symbol	expTime
symbol	expTimeActive
symbol	expTimeEnd
symbol	expTimeInterval
symbol	expTimeLbl
symbol	startDay
symbol	tempTime
symbol	stopExpTime
symbol	GetTimeInSecsHr
in	GetTimeInSecs	INT_RPC	?d,s	GetTimeInSecsHr $(Time hour);ne? "$1" "" ne? $(Time day) $1 GetTimeInSecsHr $(+ $(GetTimeInSecsHr) 24);return $(+ $(* $(+ $(* $(GetTimeInSecsHr) 60) $(Time minute)) 60) $(Time second))
macro	CountExpTime	expTimeActive 1;expTime $(- $(expTimeEnd) $(GetTimeInSecs $(startDay)));expTimeInterval $(+ $(% $(- $(expTime) 1) 6) 1);WinMgr after:$(expTimeInterval):CheckExpTime;expTime $(- $(expTime) $(expTimeInterval))
macro	UpdateNegTime	w0.ExpTime colors:yellowLabel;expTimeLbl $(LateLbl);tempTime $(* $(expTime) -1)
macro	UpdatePosTime	w0.ExpTime colors:default;expTimeLbl $(ExpectedLbl);tempTime $(expTime)
macro	UpdateExpTime	eq? $(min $(expTime) 0) 0 UpdatePosTime;\
			ne? $(min $(expTime) 0) 0 UpdateNegTime;\
			w0.ExpTime clear;\
			w0.ExpTime write:"$(expTimeLbl):\n$(/ $(tempTime) 60).$(/ $(% $(tempTime) 60) 6) $(MinutesLbl)";\
			ne? $(expTimeActive) 1 ne? $(max $(expTime) 0) 0 CountExpTime
macro	ClearExpTime	stopExpTime 1;w0.ExpTime clear;w0.ExpTime colors:default
macro	CheckExpTime	expTimeActive 0;ne? $(stopExpTime) 1 UpdateExpTime
in	HandleExpTime	INT_RPC	d	expTime $1;startDay $(Time day);expTimeEnd $(+ $(GetTimeInSecs $(startDay)) $(expTime));stopExpTime 0;UpdateExpTime
symbol	state		99
symbol	dfltReady	-1
symbol	ksargs		4
macro	HandleKsArg3	UpdateStatBar "Data" $3
macro	HandleKsArg4	UpdateStatBar "Data" $4
macro	HandleKsArg6	UpdateStatBar "Data" $6
symbol	iconFrame
macro	IconAnim0	iconFrame $(+ $(iconFrame) 1); \
			WinMgr after:1:IconAnim
macro	IconAnim	w0.NextAct icon:$(icon.$(state))_$(iconFrame); \
			ne? $(iconFrame) 2 IconAnim0
macro	IconInit	w0.NextAct icon:$(icon.$1); \
			iconFrame 1; \
			WinMgr cancel:IconAnim; \
                        eq? $(anim.$1) y WinMgr after:1:IconAnim
macro	HandleNextAct	ne? $1 $(state) IconInit; \
			w0.CurAct label:$2; \
			tbt_goto $2; \
			w0.NextAct label:$3
macro	HandleKstate	eq? $(min $(ksargs) 4) 4 HandleNextAct; \
			state $1; \
			postTrans $5; \
			HandleKsArg$(ksargs); \
			do_kstate_extra; \
			defaultValue $7; \
			ne? "$(defaultValue)" " " HandleExpTime $7; \
			eq? "$(defaultValue)" " " ClearExpTime; \
			CheckPerspective$(tbt_support); \
			eq? $(commstat) yes eq? $(state) 10 UpdateMatl; \
			eq? $(commstat) yes eq? $(state) 7 UpdateLastShvLoc
macro	doKstate	HandleKstate
macro	doKstate2	HandleKstate
macro	doReadyChk	READY $(dfltReady)
macro	doShvReady	doReadyChk
macro	doNoFull	MessageBox "$(ShvlWaitLbl)" "$(ConfirmActLbl)"

/* KSTATE3 macros */
symbol	curr_stat
symbol	curr_rsn
symbol	curr_oper
symbol	curr_rcode
symbol	curr_loc
symbol	curr_bcms
symbol	shift_bcms
symbol	curr_tons
symbol	shift_tons
symbol  curr_truck
symbol	bcm_mode
symbol	last_bcm_mode
symbol	eqinfo_clear
symbol  ks3arg
message	stat1_icon	stat_down
message	stat2_icon	stat_ready
message	stat3_icon	stat_standby
message	stat4_icon	stat_delay
message	stat5_icon	stat_tiedown
macro	HandleStatInfo	curr_stat $1;curr_rsn $2;curr_oper $3;curr_rcode $4;curr_loc $5;\
			eq? "$(curr_oper)" "-1" curr_oper $(nil);\
			w0.Status icon:$(stat$(curr_stat)_icon);\
			ShowOperator$(tbt_support);\
			Handleks3arg6;\
			Handleks3arg7;\
			PublishUser;\
			PublishOperatingState;
macro   HandleBcmInfo   eqinfo_clear 1;bcm_mode $2;curr_bcms $3;shift_bcms $4;curr_tons $5;shift_tons $6;curr_truck $7;\
                        eq? $(bcm_mode) 0 eq? $(bcm_mode) $(last_bcm_mode) eqinfo_clear 0;\
                        eq? $(eqinfo_clear) 1 EqInfo.Text clear;\
                        EqInfo.Text write:"\n$(curr_truck) $(msg.bcm$(bcm_mode)) $(curr_bcms) $(msg.bcmunit) / $(curr_tons) $(msg.tonunit)\n";\
                        ne? $(bcm_mode) 0 EqInfo.Text write:"\n$(msg.bcmshift$(bcm_mode)) $(shift_bcms) $(msg.bcmunit) / $(shift_tons) $(msg.tonunit)\n";\
                        last_bcm_mode $(bcm_mode)
macro	HandleSFInfo	ks3arg $1
macro	Handleks3arg6	ks3arg $1
#ifdef DELITE
macro	Handleks3arg7	ks3arg $1
#else
macro	Handleks3arg7	Report operatorId:$7
#endif
macro	doKstate3	eq? $(min $1 5) $1 HandleStatInfo;eq? $1 6 HandleBcmInfo;eq? $1 7 HandleSFInfo;eq? $1 8 HandleSFInfo

/* Dynamic Menus */
symbol	menuMore
symbol	menuType
symbol	menuMethod
/* to support new GenMenu we want the ability to send a different menuType name
 * when an update is requested. In that case altMenuUpdt is set to 1 and menuType2
 * is set to alternate name. See NewStat option for example */
symbol	altMenuUpdt	0
symbol	menuType2
/* for some options we need to do some special things for update request.
 * passing 1 as third arg for PostDynamicMenu and assigning a macro name 
 * to altUpdtName when menu is called will allow for alternate function to 
 * be run instead of standard update macro */
symbol  altUpdtExpr	0
symbol	altUpdtName
in	PostDynamicMenu	INT_RPC	s?ss	menuMore 1;menuType $1;menuMethod $2;altUpdtExpr $3;$1 post
macro	NextMenu	menuMore $(+ $(menuMore) 1);$(menuType)$(menuMore) post
macro	MenuAction2	eq? "$1" "$(updtstr)" doMenuUpdate;ne? "$1" "$(updtstr)" $(menuMethod);altMenuUpdt 0;altUpdtExpr 0
macro	MenuAction1	eq? "$1" "$(morestr)" NextMenu;ne? "$1" "$(morestr)" MenuAction2
in	MenuAction	INT_RPC	s	ne? "$1" "$(exitstr)" MenuAction1;eq? "$1" "$(exitstr)" 'altMenuUpdt 0;altUpdtExpr 0'
macro	doMenuAction	MenuAction "$0"
macro	doMenuUpdate	eq? "$(menuType)" "Status" doClearStatusMenus;\
                        eq? $(altUpdtExpr) 1 $(altUpdtName);\
                        ne? $(altUpdtExpr) 1 StdMenuUpdate;altUpdtExpr 0
macro	StdMenuUpdate   eq? $(altMenuUpdt) 1 EQ-REQ "update" "$(menuType2)";\
                        eq? $(altMenuUpdt) 0 EQ-REQ "update" "$(menuType)";altMenuUpdt 0

/* Status */
in	StatusAction	INT_RPC	ss	menuType $1;MenuAction "$2"
macro	doReadyAction	StatusAction "Ready" "$0"
macro	doDownAction	StatusAction "Down" "$0"
macro	doDelayAction	StatusAction "Delay" "$0"
macro	doStandbyAction	StatusAction "Standby" "$0"
symbol listStatusMenus "Ready Down Delay Standby"
symbol pagStatusMenus "2 3 4"
symbol currStatusMenu
macro doClearStatusSubMenus foreach $(pagStatusMenus);do '\$(currStatusMenu)\$2 items'
macro doClearStatusMenus foreach $(listStatusMenus);do '\$2 items;currStatusMenu \$2;doClearStatusSubMenus'

/* Locs */
/* list of locations based on values in Central.h */
#ifdef LT1
	message	loclist	LT1
#endif
#ifdef LT2
	message	loclist	LT1 LT2
#endif
#ifdef LT3
	message	loclist	LT1 LT2 LT3
#endif
#ifdef LT4
	message	loclist	LT1 LT2 LT3 LT4
#endif
#ifdef LT5
	message	loclist	LT1 LT2 LT3 LT4 LT5
#endif
#ifdef LT6
	message	loclist	LT1 LT2 LT3 LT4 LT5 LT6
#endif
#ifdef LT7
	message	loclist	LT1 LT2 LT3 LT4 LT5 LT6 LT7
#endif
#ifdef LT8
	message	loclist	LT1 LT2 LT3 LT4 LT5 LT6 LT7 LT8
#endif
#ifdef LT9
	message	loclist	LT1 LT2 LT3 LT4 LT5 LT6 LT7 LT8 LT9
#endif
#ifdef LT10
	message	loclist	LT1 LT2 LT3 LT4 LT5 LT6 LT7 LT8 LT9 LT10
#endif
#ifdef LT11
	message	loclist	LT1 LT2 LT3 LT4 LT5 LT6 LT7 LT8 LT9 LT10 LT11
#endif
#ifdef LT12
	message	loclist	LT1 LT2 LT3 LT4 LT5 LT6 LT7 LT8 LT9 LT10 LT11 LT12
#endif
#ifdef LT1
	symbol	unum
	symbol	locMethod
	in	CompareLocType	INT_RPC	ss	eq? "$(u$1)" "$2" unum $1
	macro	SelectLocType	foreach $(loclist);do CompareLocType "\$2" "$1";PostDynamicMenu "LUnit$(unum)" $(locMethod)
	in	PostLocs	INT_RPC	s	locMethod $1;PostDynamicMenu "Locs" "SelectLocType"
#endif

/* w0 */
macro	SendChatMsg	MESSAGE "$(GetPadValue)"; kbopen n
macro	doActions	Actions post
macro	doStatus	PostDynamicMenu "Status"
macro	doOptions	Options post
macro	doNextAction	rpc.$(state)
macro	doChat		eq? $(SpeedMsg) y SpeedMsgChat;ne? $(SpeedMsg) y PostChat
macro	PostChat	PostKeyPad "$(EnterMsgLbl)" SendChatMsg $(MsgMaxLen)
macro	doClear		eq? "$(curWindow)" " " ClearTrans;ne? "$(curWindow)" " " $(curWindow).Text clear
macro	doColor		Colors post

/* Actions */
macro	NotAvailable	MessageBox "$(NotAvailableLbl)" "$(ErrorLbl)"
macro	SendLogIn	LOGON "$(GetPadValue)"
#ifdef ALPHNUMOPER
macro	doActLogOn	PostAlphaNumPad "$(PayrollLbl)" SendLogIn
#else
macro	doActLogOn	PostNumPad "$(PayrollLbl)" SendLogIn
#endif
macro	doLogOff	LOGON -1
#if DEMAJOR >= 6 && ((DEMINOR >= 6 && DEMAINT >= 8) || DEMINOR >= 7)
#ifdef GPSTAGACT
macro	doActArrive	ARRIVE -1 [\"$(Time epoch)\"] [ $(GpsTruck x) $(GpsTruck y) $(GpsTruck z) $(GpsTruck velocity) $(GpsTruck status) ]
macro	doActLoad	LOAD -1 [\"$(Time epoch)\"] [ $(GpsTruck x) $(GpsTruck y) $(GpsTruck z) $(GpsTruck velocity) $(GpsTruck status) ]
macro	doStartDump	EQ-REQ "startdump" [\"$(Time epoch)\"]
macro	doActAssign	ASSIGN -1 [\"$(Time epoch)\"] [ $(GpsTruck x) $(GpsTruck y) $(GpsTruck z) $(GpsTruck velocity) $(GpsTruck status) ]
#else
macro	doActArrive	ARRIVE -1 [\"$(Time epoch)\"]
macro	doActLoad	LOAD -1 [\"$(Time epoch)\"]
macro	doStartDump	EQ-REQ "startdump" [\"$(Time epoch)\"]
macro	doActAssign	ASSIGN -1 [\"$(Time epoch)\"]
#endif
#elif DEMAJOR >= 6 && DEMINOR >= 6 && DEMAINT >= 3
macro	doActArrive	ARRIVE -1 [\"$(Time epoch)\"]
macro	doActLoad	LOAD -1 [\"$(Time epoch)\"]
macro	doStartDump	EQ-REQ "startdump" [\"$(Time epoch)\"]
macro	doActAssign	ASSIGN -1 [\"$(Time epoch)\"]
#else
macro	doActArrive	ARRIVE -1
macro	doActLoad	LOAD -1
macro	doStartDump	EQ-REQ "startdump"
macro	doActAssign	ASSIGN -1
#endif
#ifdef CAN_FUEL
	macro	SendFuel	FUEL "$(GetPadValue)"
	macro	NoFuel	        FUEL -1
#if (DEMAJOR >= 6 && DEMINOR >= 7)
	macro	doActFuel	PostNoneNumPad "$(FuelLbl)" SendFuel 0 "" NoFuel
#else
	macro	doActFuel	PostNumPad "$(FuelLbl)" SendFuel 0
#endif
        macro   kpCallFuel	doActFuel
#endif

	symbol	use2engines	n
	symbol	enghour0	
	symbol	enghour1	
	macro	GetEngHour0	enghour0 $(GetPadValue);Post2EngReq
	macro	GetEngHour1	enghour1 $(GetPadValue);Post2EngReq
	macro	PostEngHr0	PostDotNumPad "$(EngHoursLbl) - $(TwoEngine0)" GetEngHour0
	macro	PostEngHr1	PostDotNumPad "$(EngHoursLbl) - $(TwoEngine1)" GetEngHour1
	macro	CleanEngHrVal	enghour0 ""; enghour1 ""
	macro	Post2EngReq	TwoEng post
	macro	SendEngHours	EQ-REQ "eng_hrs" [ "$(GetPadValue)" ]
	macro	Send2EngHours	EQ-REQ "eng_hrs" [ "$(enghour0)" "$(enghour1)" ];CleanEngHrVal
	macro	do2EngHrs	Post2EngReq
	macro	do1EngHr	PostDotNumPad "$(EngHoursLbl)" SendEngHours
	macro	doEngHours	eq? "$(use2engines)" "y" do2EngHrs;\
				ne? "$(use2engines)" "y" do1EngHr
				
macro	doNo		EQ-REQ "no"
macro	doYes		EQ-REQ "yes"
macro	doActionsExit	Actions unpost

/* Icons assigned to each state */
symbol	icon.99	logo
symbol	anim.99 n
symbol	icon.0	logo
symbol	anim.0	n
symbol	icon.1	down
symbol	anim.1	n
symbol	icon.2	ready
symbol	anim.2	n
symbol	icon.3	standby
symbol	anim.3	n
symbol	icon.4	delay
symbol	anim.4	n
symbol	icon.5	tiedown
symbol	anim.5	n
symbol	icon.6	empty
symbol	anim.6	y
symbol	icon.7	waiting
symbol	anim.7	y
symbol	icon.8	loading
symbol	anim.8	y
symbol	icon.9	hauling
symbol	anim.9	y
symbol	icon.10	dumping
symbol	anim.10	y
symbol	icon.11	none
symbol	anim.11	n
symbol	icon.12	none
symbol	anim.12	n
symbol	icon.13	none
symbol	anim.13	n
symbol	icon.14	empty
symbol	anim.14	y
symbol	icon.15	empty
symbol	anim.15	y
symbol	icon.16	loading
symbol	anim.16	y
symbol	icon.17	loading
symbol	anim.17	y
symbol	icon.18	hauling
symbol	anim.18	y
/* RPCs or Macros assigned to each state */
macro	rpc.0	doActLogOn
macro	rpc.1	doReadyChk
macro	rpc.2	doActAssign
macro	rpc.3	doReadyChk
macro	rpc.4	doReadyChk
macro	rpc.5	doReadyChk
macro	rpc.6	doActArrive
macro	rpc.7	doActLoad
macro	rpc.8	doActFull
macro	rpc.9	doActArrive
macro	rpc.10	doActAssign
macro	rpc.11	doActArrive
macro	rpc.12	doActAssign
macro	rpc.13	doActAssign
macro	rpc.14	doActFull
macro	rpc.15	doActLoad
macro	rpc.16	doActFull
macro	rpc.17	doNoFull
macro	rpc.18	doStartDump
macro	rpc.99	PowerUp

/* Prestart */
#ifdef  ENHANCEPS
#	define	PSNEW_FILE <10inch/common/Prestart2_Macro.cfg>
#	include PSNEW_FILE
#else
#ifdef PSCHECK
	symbol	psLists -1
	symbol	lastpage.0 -1
	symbol	lastpage.1 -1
	symbol	lastpage.2 -1
	symbol	lastpage.3 -1
	symbol	lastpage.4 -1
	symbol	lastpage.5 -1
	symbol	lastpage.6 -1
	symbol	lastpage.7 -1
	symbol	lastpage.8 -1
	symbol	lastpage.9 -1
	symbol	noShow	2
#	define PS_FILE <PS/generic/Macro.cfg>
#	include PS_FILE
#	if #ctype(loaderlp)
#		define PS_FILE <PS/loader/Macro.cfg>
#	elif #ctype(ug_loader) || #ctype(ug_truck)
#		define PS_FILE <PS/CTYPE/Macro.cfg>
#	else
#		define PS_FILE <PS/APP/Macro.cfg>
#	endif
#	include PS_FILE
	symbol  psMap
	symbol  psInitVal
	symbol	psTemp
	symbol	psTemp2
	symbol	prevPsPage
	symbol	bitmask
	symbol	PsValue
	symbol	pageArray
	symbol	PsItem
	symbol	PsPage
	symbol	PsList	0
	symbol	PsComment.0
	symbol	PsComment.1
	symbol	PsComment.2
	symbol	PsComment.3
	symbol	PsComment.4
	symbol	PsComment.5
	symbol	PsComment.6
	symbol	PsComment.7
	symbol	PsComment.8
	symbol	PsComment.9
	symbol	PsLoading
	symbol	PsDoNotOperate
	symbol  PsIncomplete
	symbol	PsNoConfig
	symbol	PsValue0	Pass
	symbol	PsValue1	Fail
	symbol	PsValue2	Neutral
        symbol  PsValue3        SafeFail
        symbol  ColorVal
	symbol  currItemState	
	symbol	temp_oper
	symbol  PassAllRestrict y
	message	PsNoOperateEnum	3
        message PsSafeFailEnum  4
        message PsPassEnum      0
        message PsFailEnum      1
        message PsNeutEnum      2
	in	RefreshItemCmt	INT_RPC	d	psTemp2 default;ne? "$(Cfg.ps.$(PsList).$(PsPage).$1)" " " psTemp2 $(PsValue0);Prestart.Comment$1 colors:$(psTemp2)
	macro	RefreshItem0	PsItem $1;RefreshItemTog $1;RefreshItemCmt $1;psTemp2 $(PsIcon.$(PsList).$(PsPage).$1);eq? "$(psTemp2)" " " Prestart.Toggle$1 icon:$(nil);ne? "$(psTemp2)" " " Prestart.Toggle$1 icon:$(psTemp2)
	in	RefreshItem	INT_RPC	dd	psMap 0;ne? $2 $(noShow) psMap 1;psTemp $(- 2 $2);ne? $(psMap) 0 RefreshItem0;Prestart.Group$1 map:$(psMap);Prestart.Toggle$1 map:$(psMap);Prestart.Comment$1 map:$(psMap)
#	in	RefreshItemTog	INT_RPC	d	ColorVal $1;Prestart.Toggle$1 colors:$(PsValue$(ps.$(PsList).$(PsPage).$(ColorVal))) label:"$(CfgPs.$(PsList).$(PsPage).$1) : $($(PsValue$(ps.$(PsList).$(PsPage).$1))Lbl)"
	in	RefreshItemTog	INT_RPC	d	ColorVal $(ps.$(PsList).$(PsPage).$1);\
                                                eq? $(ps.$(PsList).$(PsPage).$1) $(PsFailEnum) eq? $(PsAction.$(PsList).$(PsPage).$1) $(PsSafeFailEnum) ColorVal 3;\
                                                Prestart.Toggle$1 colors:$(PsValue$(ColorVal)) label:"$(CfgPs.$(PsList).$(PsPage).$1)"
	in	SetItem		INT_RPC	ddd	ps.$(PsList).$1.$2 $3;DSItemState2$(persist_support) $(PsList) $1 $2;eq? $(PsPage) $1 RefreshItemTog $2
	in	FailItem	INT_RPC	dd	SetItem $1 $2 1
	in	PassItem	INT_RPC	dd	SetItem $1 $2 0
	in	PassItemRestrict	INT_RPC	dd	ne? $(ps.$(PsList).$1.$2) $(PsFailEnum) SetItem $1 $2 0
	macro	BitmaskItem0	PsValue $(+ $(PsValue) $(bitmask));eq? $(PsAction.$(PsList).$1.$2) $(PsNoOperateEnum) PsDoNotOperate 1
	in	BitmaskItem	INT_RPC	dd	eq? $(ps.$(PsList).$1.$2) 2 PsIncomplete 1;eq? $(ps.$(PsList).$1.$2) 1 BitmaskItem0;bitmask $(* $(bitmask) 2)
	in	LoopAllItems	INT_RPC	ds	foreach $(PsInit.$(PsList).$1);do ne? \$2 $(noShow) $2 $1 \$1 \$2
	macro	LoopAllPages0	LoopAllItems $1 $(n)
	in	LoopAllPages	INT_RPC	s	n $1;For $(+ $(lastpage.$(PsList)) 1) LoopAllPages0
	macro	BitmaskPage	PsValue 0;bitmask 1;LoopAllItems $1 BitmaskItem;pageArray $(pageArray) $(PsValue) 
	macro	RefreshPage	PageCleanup;foreach $(PsInit.$(PsList).$(PsPage));do RefreshItem \$1 \$2
	macro	SetPage0	PsLoading 1;Prestart.Loading map:y;PsPage $1;Prestart.Page label:"$(PageLbl): $(+ $(PsPage) 1) / $(+ $(lastpage.$(PsList)) 1)";RefreshPage;Prestart.Loading map:n;PsLoading 0
	in	SetPage		INT_RPC	d	SetPage0
	macro	PsPrev		PsValue $(PsPage);ne? $(PsValue) 0 SetPage $(- $(PsValue) 1);eq? $(PsValue) 0 SetPage $(lastpage.$(PsList))
	macro	doPsPrev	ne? $(PsLoading) 1 PsPrev
	macro	PsNext		PsValue $(PsPage);ne? $(PsValue) $(lastpage.$(PsList)) SetPage $(+ $(PsValue) 1);eq? $(PsValue) $(lastpage.$(PsList)) SetPage 0
	macro	doPsNext	ne? $(PsLoading) 1 PsNext
	macro	PsPassAll	prevPsPage $(PsPage);PsNext;\
                                eq? "$(PassAllRestrict)" "n" LoopAllItems $(prevPsPage) PassItem;\
                                ne? "$(PassAllRestrict)" "n" LoopAllItems $(prevPsPage) PassItemRestrict
	/*macro	doPsPassAll	ne? $(PsLoading) 1 PsPassAll*/
	in	doPsToggle	INT_RPC	d	PsItem $1;currItemState $(ps.$(PsList).$(PsPage).$1);\
                                                eq? $(currItemState) $(PsNeutEnum) SetItem $(PsPage) $1 $(PsPassEnum);\
                                                ne? $(currItemState) $(PsNeutEnum) SetItem $(PsPage) $1 $(- 1 $(ps.$(PsList).$(PsPage).$1));\
                                                SetCommentArea
	macro	SetGenComment	PsComment.$(PsList) $(GetPadValue2);RefreshComment;DSGenCmt$(persist_support);SetCommentArea
	macro	SetItemComment2	ne? "$(GetPadValue2)" " " SetItemComment2
	macro	SetItemComment	Cfg.ps.$(PsList).$(PsPage).$(PsItem) $(GetPadValue2);RefreshItemCmt $(PsItem);DSItemCmt$(persist_support);SetCommentArea;EQ-REQ "psitemcomment" [ $(PsList) $(PsPage) $(PsItem) "$(Cfg.ps.$(PsList).$(PsPage).$(PsItem))" ]
#	ifdef ENHANCEPS
	        macro	InitPersist	WinMgr after:1:InitPS;eq? $(ChecklistItem debug) no persist_support PY
		symbol	MaxCommLen	140
		macro	editPsComment eq? $(PsItem) 99 PostKeyPad "$(CommentTitle)" SetGenComment $(MaxCommLen) "$(PsComment.$(PsList))";\
				      ne? $(PsItem) 99 PostKeyPad "$(CommentTitle)" "SetItemComment" $(MaxCommLen) "$(Cfg.ps.$(PsList).$(PsPage).$(PsItem))"
		macro	RefreshComment  eq? "$(PsComment.$(PsList))" " " Prestart.Comment colors:default;ne? "$(PsComment.$(PsList))" " " Prestart.Comment colors:$(PsValue0)
                macro	SetCommentArea	RefreshCommHead$(persist_support) $(GetItemName) $(GetCmtDate$(persist_support)) $(GetCmtOper$(persist_support));RefreshCommDisp
		in      doPsComment     INT_RPC d       PsItem $1;SetCommentArea;\
                                                        eq? $(PsItem) 99 eq? "$(PsComment.$(PsList))" " " editPsComment;\
                                                        ne? $(PsItem) 99 eq? "$(Cfg.ps.$(PsList).$(PsPage).$1)" " " editPsComment
		symbol	tempItemName
		in	GetItemName	INT_RPC ?s,s	eq? $(PsItem) 99 tempItemName $(General);ne? $(PsItem) 99 tempItemName $(CfgPs.$(PsList).$(PsPage).$(PsItem)); return "$(tempItemName)"
#		ifdef PERSISTSUPPORT
                        macro	CheckPS	postTrans "Persistence Support via DEMAINT check"
#		else
			macro	CheckPS	postTrans "Persistence Support using $(persist_support) macros"
#		endif
/*
 *              Until we can check DEMAINT version use this to determine if persistence support is available
 */
/*
 * Persistent Support
 */
                symbol	dsobj
                symbol  dstemp
		symbol	dsresult
                macro	SetChecklistItem  eq? $(PsItem) 99 ChecklistItem list:$(PsList) page:0 item:$(PsItem);\
                                          ne? $(PsItem) 99 ChecklistItem list:$(PsList) page:$(PsPage) item:$(PsItem)
                in	SetChecklistItem2  INT_RPC ddd	eq? $(PsItem) 99 ChecklistItem list:$1 page:0 item:$3;\
                                          ne? $(PsItem) 99 ChecklistItem list:$1 page:$2 item:$3
		in      GetItemStatePY    INT_RPC ?s,s	SetChecklistItem;return "$(ChecklistItem state)"
		in      GetCmtDatePY      INT_RPC ?s,s	SetChecklistItem;dstemp $(ChecklistItem date);\
                                                        eq? "$(dstemp)" " " dsresult "?";\
                                                        ne? "$(dstemp)" " " dsresult $(dstemp);\
                                                        return "$(dsresult)"
                in      GetCmtOperPY      INT_RPC ?s,s	SetChecklistItem;dstemp $(ChecklistItem oper);\
                                                        eq? "$(dstemp)" " " dsresult "?";\
                                                        ne? "$(dstemp)" " " dsresult $(dstemp);\
                                                        return "$(dsresult)"
		in      GetCmtTextPY      INT_RPC ?s,s	SetChecklistItem;return "$(ChecklistItem comment)"
		in      RefreshCommHeadPY INT_RPC sss	eq? "$2" "?" Prestart.CommHead label:$(LastComm);\
                                                        eq? "$3" "?" Prestart.CommHead label:$(LastComm);\
                                                        ne? "$2" "?" ne? "$3" "?" Prestart.CommHead label:$(LastCommEnhan)
		macro   ResetCommentsPY	  PsItem 99;SetChecklistItem;dstemp $(ChecklistItem comment);\
                                          eq? "$(dstemp)" " " PsComment.$(PsList) $(nil);\
                                          ne? "$(dstemp)" " " PsComment.$(PsList) $(dstemp)  
                in      ResetItemPY	  INT_RPC ddd	PsPage $1;PsItem $2;SetChecklistItem;dstemp $(ChecklistItem state);\
                                          eq? $(dstemp) $(PsFailEnum) ps.$(PsList).$1.$2 $(PsFailEnum);\
                                          ne? $(dstemp) $(PsFailEnum) ps.$(PsList).$1.$2 $3;\
                                          dstemp $(ChecklistItem comment);\
                                          eq? "$(dstemp)" " " Cfg.ps.$(PsList).$1.$2 $(nil);\
                                          ne? "$(dstemp)" " " Cfg.ps.$(PsList).$1.$2 $(dstemp)
		macro   DSItemStatePY     SetChecklistItem;ChecklistItem state:$(ps.$(PsList).$(PsPage).$(PsItem));\
                                          eq? "$(Cfg.ps.$(PsList).$(PsPage).$(PsItem))" " " ChecklistItem date:"";\
                                          eq? "$(Cfg.ps.$(PsList).$(PsPage).$(PsItem))" " " ChecklistItem oper:"";\
                                          eq? "$(Cfg.ps.$(PsList).$(PsPage).$(PsItem))" " " ChecklistItem comment:""
		in	DSItemState2PY    INT_RPC ddd SetChecklistItem2 $1 $2 $3;ChecklistItem state:$(ps.$1.$2.$3);\
                                          eq? "$(Cfg.ps.$1.$2.$3)" " " ChecklistItem date:"";\
                                          eq? "$(Cfg.ps.$1.$2.$3)" " " ChecklistItem oper:"";\
                                          eq? "$(Cfg.ps.$1.$2.$3)" " " ChecklistItem comment:""
                macro   DSItemCmtPY       SetChecklistItem;\
                                          eq? "$(Cfg.ps.$(PsList).$(PsPage).$(PsItem))" " " ChecklistItem date:$(nil);\
                                          ne? "$(Cfg.ps.$(PsList).$(PsPage).$(PsItem))" " " ChecklistItem date:$(FormatDate);\
                                          eq? "$(Cfg.ps.$(PsList).$(PsPage).$(PsItem))" " " ChecklistItem oper:$(nil);\
                                          ne? "$(Cfg.ps.$(PsList).$(PsPage).$(PsItem))" " " ChecklistItem oper:$(curr_oper);\
                                          ChecklistItem comment:$(Cfg.ps.$(PsList).$(PsPage).$(PsItem));\
                                          ChecklistItem state:$(ps.$(PsList).$(PsPage).$(PsItem))
		macro	DSGenCmtPY        SetChecklistItem;\
                                          eq? "$(PsComment.$(PsList))" " " ChecklistItem date:$(nil);\
                                          ne? "$(PsComment.$(PsList))" " " ChecklistItem date:$(FormatDate);\
                                          eq? "$(PsComment.$(PsList))" " " ChecklistItem oper:$(nil);\
                                          ne? "$(PsComment.$(PsList))" " " ChecklistItem oper:$(curr_oper);\
                                          ChecklistItem comment:$(PsComment.$(PsList));\
                                          ChecklistItem state:0
/*
 * Non Persistent Support
 */
		in      GetItemStatePN    INT_RPC ?s,s	return $(nil)
		in      GetCmtDatePN      INT_RPC ?s,s    return "$(Time month)/$(Time day)/$(Time year) ($(Time get))"
		in      GetCmtOperPN      INT_RPC ?s,s    eq? "$(curr_oper)" " " temp_oper "Unknown";ne? "$(curr_oper)" " " temp_oper $(curr_oper);return $(temp_oper)
                in      GetCmtTextPN      INT_RPC ?s,s    return $(nil)
                in      RefreshCommHeadPN INT_RPC sss     Prestart.CommHead label:$(LastComm)
                macro   ResetCommentsPN   PsComment.$(PsList) $(nil)
                in      ResetItemPN       INT_RPC ddd     Cfg.ps.$(PsList).$1.$2 $(nil);ps.$(PsList).$1.$2 $3
                macro   DSItemStatePN     nil
                in	DSItemState2PN    INT_RPC ddd	nil
                macro   DSItemCmtPN       nil
		macro	DSGenCmtPN        nil
/*
 * end Persistent dependant code
 */
		macro	RefreshCommDisp Prestart.CommDisp clear;\
                                        eq? $(PsItem) 99 Prestart.CommDisp label:$(PsComment.$(PsList));\
                                        ne? $(PsItem) 99 Prestart.CommDisp label:$(Cfg.ps.$(PsList).$(PsPage).$(PsItem))
		macro	PageCleanup	Prestart.CommDisp label:"";Prestart.CommHead label:""
#	else
/*
 * force persist_support to no if ENHANCE_PS is off
 */
	        macro	InitPersist	WinMgr after:1:InitPS;persist_support PN
		macro	SetCommentArea	nil
		macro	RefreshComment	eq? "$(PsComment.$(PsList))" " " Prestart.Comment label:"$(GenCommentLbl)";ne? "$(PsComment.$(PsList))" " " Prestart.Comment label:"$(PsComment.$(PsList))"
		macro	doPsGenComment	PostKeyPad "$(CommentTitle)" SetGenComment $(dfltKPLen) "$(PsComment.$(PsList))"
		in	doPsComment	INT_RPC	d	PsItem $1;PostKeyPad "$(CommentTitle)" "SetItemComment" $(dfltKPLen) "$(Cfg.ps.$(PsList).$(PsPage).$(PsItem))"
		macro	ResetCommentsPN	PsComment.$(PsList) $(nil)
		in	ResetItemPN	INT_RPC	ddd	Cfg.ps.$(PsList).$1.$2 $(nil);ps.$(PsList).$1.$2 $3
		macro	PageCleanup	nil
                macro	DSItemStatePN	nil
                in	DSItemState2PN    INT_RPC ddd	nil
		macro	DSItemCmtPN	nil
		macro	DSGenCmtPN      nil
#	endif
	macro	PsTellNoOperate	MessageBox "$(PsCritFailLbl)" "$(PressOkLbl)";postTrans "$(PsCritFailLbl)\n$(DoNotOperateLbl)"
        macro	PsTellIncomplete MessageBox "$(PsIncompleteLbl)" "$(PressOkLbl)";doPsCheck $(PsList)

	macro	doPsCancel	UnpostWindow "Prestart"
	in	UnmaskActionBit	INT_RPC	d	ne? $(/ $(% $(psTemp2) $(psTemp)) $(bitmask)) 0 PsValue $(+ $(PsValue) $1);bitmask $(psTemp);psTemp $(* $(psTemp) 2)
                                                                                        /* Attempt to prevent pressing OK        */
                                                                                        /* Remove button action until processing */
	macro   doPsOk          Prestart.Ok action:"";\                                 /* of doPsOk logic is complete           */
                                UnpostWindow "Prestart";\                               /* Unpost window at begining of sequence */
                                PsDoNotOperate 0;PsIncomplete 0;\
                                pageArray $(nil);\
                                For $(+ $(lastpage.$(PsList)) 1) BitmaskPage;\
                                n $(PsComment.$(PsList));\
                                eq? "$(n)" " " n $(NoneLbl);\
                                eq? $(PsIncomplete) 0 PRESTART $(pstype) "$(PsList)|$(n)" [ $(pageArray) ];\
                                eq? $(PsIncomplete) 0 eq? $(PsDoNotOperate) 1 PsTellNoOperate;\
                                Prestart.Ok action:doPsOk;\                             /* Add doPsOk action to Prestar.Ok button */
                                ne? $(PsIncomplete) 0 PsTellIncomplete
	in	UnmaskItem	INT_RPC	dd	PsValue 0;UnmaskActionBit 1;UnmaskActionBit 2;PsAction.$(PsList).$1.$2 $(PsValue)
	in	UnmaskActions	INT_RPC	dd	psTemp2 $2;bitmask 1;psTemp 2;LoopAllItems $1 UnmaskItem

	/* these are GCDO'd by central */
	in	doPsUnmaskActs	INT_RPC	[d]	foreach $1;do UnmaskActions \$1 \$2
	in	kpPrestart	INT_RPC	d	PsList 0;ne? "$1" "-1" PsList $1;eq? $(lastpage.$(PsList)) -1 ShowNoPS;ne? $(lastpage.$(PsList)) -1 'WinMgr after:1:kpPSAuto'
	macro	checkReset	eq? $(PsLoading) 0 endReset;\
				eq? $(PsLoading) 1 WinMgr after:1:checkReset
	macro	endReset	Prestart.Loading map:n
	macro	kpPSAuto	Prestart.Loading map:y;PsPage 0;RefreshComment;Prestart.Page label:"$(PageLbl): $(+ $(PsPage) 1) / $(+ $(lastpage.$(PsList)) 1)";RefreshPage;PostWindow "Prestart" MENU_LAYER;checkReset
	macro	ResetAllPS	PsLoading 1;ResetComments$(persist_support);RefreshComment;LoopAllPages ResetItem$(persist_support);PsLoading 0

	in	doPsCheck	INT_RPC	d	PsList $1;eq? $(lastpage.$(PsList)) -1 ShowNoPS;ne? $(lastpage.$(PsList)) -1 ShowPsCheck
	macro	ShowPsCheck	SetPage 0;RefreshComment;PostWindow "Prestart" MENU_LAYER
	macro	ShowNoPS	PsNoConfig "$(PrestartTitle)\n$(NoConfig)";MessageBox "$(PsNoConfig)" "$(PressOkLbl)"
	in	InitPS0		INT_RPC	d	PsList $1;ne? $(lastpage.$(PsList)) -1 ResetAllPS
	macro	InitPS		ne? $(psLists) -1 initPSLists
	macro	initPSLists	foreach $(psLists); do InitPS0 \$2
	in	BuildMenuItem	INT_RPC	d	n "'$(PrestartTitle.$1)' doPsCheck $1";Checklists item:$(n)
	macro	PostChecklists	foreach $(psLists);do BuildMenuItem \$2;Checklists item:"'$(exitstr)' Checklists unpost";Checklists post
	macro	ChecklistMsg	eq? $(psLists) -1 ShowNoPS;ne? $(psLists) -1 ShowlistMsgBox
	macro	ShowlistMsgBox	eq? $(nPsLists) 1 doPsCheck $(psLists);ne? $(nPsLists) 1 MessageBox "$(SelInitCLLbl)" "$(PressOkLbl)" "PostChecklists"
#	ifndef NEXTGEN
		macro	doPsReport	PostWindow "PsReport" MENU_LAYER
		macro	doPsRepUpdate	PsReport.Text clear;PsReport.Text write:"$(RepRequestLbl)";REPT-REQ PsReport.Text gc_ps_rept
		macro	doPsRepExit	UnpostWindow "PsReport"
#	endif
#else
        in	doPsUnmaskActs	INT_RPC [d]	""
	in	kpPrestart	INT_RPC	?d	""
	macro	ResetAllPS	""
	macro   InitPS		""
	macro	InitPersist	""
#endif
#endif

/* Options */
macro	doOptRecall	RECALL
macro	doRefresh	WinMgr refresh
macro	doLock		Screen lock
macro	doOptionsExit	Options unpost

/* Colors */
symbol last_color	blue

macro	doBlue		last_color blue;   Screen colors:default,blue50:white,green:white,blue25:blue75,black:white
macro	doGreen		last_color green;  Screen colors:default,green50:yellow50,red50:yellow50,green25:yellow50,black:white
macro	doGray		last_color gray;   Screen colors:default,gray75:black,red50:black,bisque25:bisque50,black:white
macro	doBrown		last_color brown;  Screen colors:default,brown50:gray75,yellow50:gray75,brown25:brown75,black:white
macro	doYellow	last_color yellow; Screen colors:default,yellow50:black,black:yellow50,brown25:brown75,black:white
macro	doRed		Screen colors:default,red50:white,black:red50,green25:yellow50,black:white; WinMgr beep:10
macro	doColorsExit	Colors unpost

macro   doLastColor     eq? $(last_color) blue   doBlue;\
                        eq? $(last_color) green  doGreen;\
                        eq? $(last_color) gray   doGray;\
                        eq? $(last_color) brown  doBrown;\
                        eq? $(last_color) yellow doYellow

/* WinMenu */
#ifdef HASVIEWS
	symbol	queueTrans
	symbol	viewLabel
	macro	AlertTrans	queueTrans $(+ $(queueTrans) 1);viewLabel "$(HomeLbl) ($(queueTrans))";w0.View colors:yellowLabel
	macro	SetWindow1	curWindow $1;WinMgr window:$1;queueTrans 0;viewLabel "$(HomeLbl)";w0.View label:"$(viewLabel)"
	in	SetWindow	INT_RPC	s	eq? "$(postedWindows)" " " SetWindow1
	macro	doTransWindow	$(curWindow) map:n;curWindow $(nil);viewLabel "$(ViewBtnLbl)";w0.View colors:default
	macro	doView		eq? "$(curWindow)" " " 'w0.View colors:default;WinMenu post';ne? "$(curWindow)" " " doTransWindow
	macro	doWinMenuExit	WinMenu unpost
	macro	AlertView	WinMgr beep:1;w0.View colors:yellowLabel;w0.Text write \n$(AlertViewLbl)\n
	macro	postViewAlert1	ne? "$(curWindow)" "$1" AlertView
	in	postViewAlert	INT_RPC s?d	ne? "$1" "" postViewAlert1
	/* EqInfo View can be used by multiple classes */
	macro	doEqInfoWindow	SetWindow "EqInfo"
	/* Operator Message */
	/* Logic now allows for out-of-sequence or dropped incoming messages. */
	in	doOperMsgList	INT_RPC	dds	OperMsgList.$1	$3;OperMsgTotItems $2;doOperMsgSwList
	in	doOperMsgText	INT_RPC	s	OperMsg.Text write $1\n
	macro	doOperMsgWindow	SetWindow "OperMsg"
	macro	doOperMsgListClear OperMsgList.$1 ""
	macro	doOperMsgRequest For $(OperMsgTotItems) doOperMsgListClear;OperMsgTotItems 0;\
				OperMsg.0 "";OperMsg.1 "";OperMsg.2 "";\
				OperMsg.Text write:$(msg.opmsgreq);EQ-REQ "opermsg" [ "opermsglist" ]
	macro	doOperMsgReq0	ne? $(OperMsg.0) "" 'OperMsg.Text clear;EQ-REQ "opermsg" [ "opermsgitem" "$(OperMsg.0)" ]'
	macro	doOperMsgReq1	ne? $(OperMsg.1) "" 'OperMsg.Text clear;EQ-REQ "opermsg" [ "opermsgitem" "$(OperMsg.1)" ]'
	macro	doOperMsgReq2	ne? $(OperMsg.2) "" 'OperMsg.Text clear;EQ-REQ "opermsg" [ "opermsgitem" "$(OperMsg.2)" ]'
	macro	doOperMsgSwList	OperMsg.Text clear;OperMsgCurPag 0;doOperMsgShow
	macro	doOperMsgShow	ne? $(min $(* $(OperMsgCurPag) $(OPMSGITEMS)) $(OperMsgTotItems)) $(OperMsgTotItems) 'OperMsg.0 $(OperMsgList.$(* $(OperMsgCurPag) $(OPMSGITEMS)))';\
				ne? $(min $(+ $(* $(OperMsgCurPag) $(OPMSGITEMS)) 1) $(OperMsgTotItems)) $(OperMsgTotItems) 'OperMsg.1 $(OperMsgList.$(+ $(* $(OperMsgCurPag) $(OPMSGITEMS)) 1))';\
				ne? $(min $(+ $(* $(OperMsgCurPag) $(OPMSGITEMS)) 2) $(OperMsgTotItems)) $(OperMsgTotItems) 'OperMsg.2 $(OperMsgList.$(+ $(* $(OperMsgCurPag) $(OPMSGITEMS)) 2))';\
				eq? $(OperMsgCurPag) 0 OperMsg.Prior icon:last_dis;ne? $(OperMsgCurPag) 0 OperMsg.Prior icon:last;\
				eq? $(max $(* $(+ $(OperMsgCurPag) 1) $(OPMSGITEMS)) $(OperMsgTotItems)) $(* $(+ $(OperMsgCurPag) 1) $(OPMSGITEMS)) OperMsg.Next icon:next_dis;\
				ne? $(max $(* $(+ $(OperMsgCurPag) 1) $(OPMSGITEMS)) $(OperMsgTotItems)) $(* $(+ $(OperMsgCurPag) 1) $(OPMSGITEMS)) OperMsg.Next icon:next
	macro	doOperMsgNxPag	OperMsgCurPag $(+ $(OperMsgCurPag) 1);OperMsg.0 "";OperMsg.1 "";OperMsg.2 "";doOperMsgShow
	macro	doOperMsgPrPag	OperMsgCurPag $(- $(OperMsgCurPag) 1);OperMsg.0 "";OperMsg.1 "";OperMsg.2 "";doOperMsgShow
	macro	doOperMsgNext	ne? $(max $(* $(+ $(OperMsgCurPag) 1) $(OPMSGITEMS)) $(OperMsgTotItems)) $(* $(+ $(OperMsgCurPag) 1) $(OPMSGITEMS)) doOperMsgNxPag
	macro	doOperMsgPrior	ne? $(OperMsgCurPag) 0 doOperMsgPrPag
	macro	doOperMsgKP	ne? "$(GetPadValue)" "" 'EQ-REQ "opermsg" [ "opermsgmesg" "$(GetPadValue)" ];doOperMsgRequest'
	macro	PostOperMsgKp	PostKeyPad $(OperMsgCreate) doOperMsgKP
	macro   PostNoOperMsg	OperMsg.Text write "$(SpeedMsgLbl)";KBEEP 2
	macro	OperMesgCkSpeed	eq? $( max $(gpsVel) $(SpeedMsgVel) ) $(SpeedMsgVel) PostOperMsgKp;eq? $( min $(gpsVel) $(SpeedMsgVel) ) $(SpeedMsgVel) PostNoOperMsg
	macro	doOperMsgKeyPad	eq? $(SpeedMsg) y OperMesgCkSpeed;ne? $(SpeedMsg) y PostOperMsgKp
	symbol	OperMsgCurPag	0
	symbol	OperMsgTotItems	0
	symbol	OperMsg.0
	symbol	OperMsg.1
	symbol	OperMsg.2
	symbol	OperMsgList.0
	symbol	OperMsgList.1
	symbol	OperMsgList.2
	symbol	OperMsgList.3
	symbol	OperMsgList.4
	symbol	OperMsgList.5
	symbol	OperMsgList.6
	symbol	OperMsgList.7
	symbol	OperMsgList.8
	symbol	OperMsgList.9
	symbol	OperMsgList.10
	symbol	OperMsgList.11
	symbol	OperMsgList.12
	symbol	OperMsgList.13
	symbol	OperMsgList.14
	symbol	OperMsgList.15
	symbol	OperMsgList.16
	symbol	OperMsgList.17
	symbol	OperMsgList.18
	symbol	OperMsgList.19
	symbol	OperMsgList.20
	symbol	OperMsgList.21
	symbol	OperMsgList.22
	symbol	OperMsgList.23
#endif

/* StatBar */

/*                                              */
/* Gps Status Functionality for DELITE Statbar  */
/*                                              */
#ifdef DELITE
	/* GpsTruck status returns a numeric value */
	symbol	GpsGoodQual	47	/*    0-31   Value will be modified in next cycle to use improved status info in PTX */
	symbol	GpsMedQual	47	/*   32-47   Value will be modified in next cycle to use improved status info in PTX */
	symbol	GpsBadQual	48	/* Bad Gps quality is 48 and up */
	symbol	gpsTruckStatus
	symbol	gpsIcon		"GpsRed"	/* Inititailized to No Gps */
	symbol	gpsOverrideStatus	""	/* If this variable is set then it is used over actual GpsTruck status */
	symbol	tempSt				/* Used in setGpsTrkStatus to hold intermediate status value */
	macro	setGpsStatus	eq? $(gpsOverrideStatus) "" setGpsTrkStatus;\
				ne? $(gpsOverrideStatus) "" gpsTruckStatus $(gpsOverrideStatus)
	/* setGpsTrkStatus converts sub-meter status codes to meter codes to avoid considering them as bad quality */
	macro	setGpsTrkStatus	tempSt $(GpsTruck status);\
				eq? $(min $(tempSt) 224) 224 eq? $(max $(tempSt) 239) 239 tempSt $(- $(tempSt) 224);\
				gpsTruckStatus $(tempSt)
	macro	setGpsIcon	StatBar.Gps icon:$(gpsIcon)
	macro	isGoodGpsQual	eq? $(min $(GpsGoodQual) $(gpsTruckStatus)) $(gpsTruckStatus) gpsIcon "GpsGreen"
	macro	isMedGpsQual	eq? $(min $(GpsMedQual)  $(gpsTruckStatus)) $(gpsTruckStatus) gpsIcon "GpsYellow"
	macro	isNoGpsQual	eq? $(max $(GpsMedQual)  $(gpsTruckStatus)) $(gpsTruckStatus) gpsIcon "GpsRed"
	macro	PollGps		setGpsStatus;\
				isNoGpsQual;\
				isMedGpsQual;\
        			isGoodGpsQual;\
				setGpsIcon
	macro	InitGps2	Vsms every:5000:PollGps
	macro	InitGps		eq? "$(GpsTruckLoaded)" "y" InitGps2
#else  
	macro	InitGps		""
#endif	/* End Gps Status Functionality */

#ifndef STATIONARY
	/* This value gets overridden in client's Central.cfg: */
	message	SpeedUnit	mph

	symbol	gpsVel		0
	symbol	velocity
	symbol	SpUnitDisplay
#	if !defined DELITE && defined DEMAINT && DEMAINT >= 3
        	macro	KeyboardSpeedClose Keyboard hide;QuickMessage hide; \
				           eq? $(kbopen) y PostNoChat;kbopen n; \
				           eq? $(qmopen) y PostNoChat2;qmopen n
#	else
        	macro	KeyboardSpeedClose Keyboard hide; \
				           eq? $(kbopen) y PostNoChat; \
				           kbopen n
#	endif
	macro	setGpsVel	gpsVel $(GpsTruck velocity); \
				eq? $(SpeedMsg) y eq? $( min $(gpsVel) $(SpeedMsgVel)) $(SpeedMsgVel) KeyboardSpeedClose
	macro	UseMph		velocity "$(/ $(gpsVel) 45)"; \
				SpUnitDisplay $(UnitMph); 
	macro	UseKph		velocity "$(/ $(* $(gpsVel) 3600) 100000)"; \
				SpUnitDisplay $(UnitKph);
	macro	PollSpeed	setGpsVel;\
				eq? "$(SpeedUnit)" "mph" UseMph; \
				eq? "$(SpeedUnit)" "km/h" UseKph; \
				UpdateStatBar "Speed" "$(velocity)\n$(SpUnitDisplay)"
#	ifndef DELITE	
		macro	SpeedFieldInit	InfoPanel addColumn:3,1; \
					InfoPanel addObject:3,Speed,Small,White,Center
#	else
		macro	SpeedFieldInit	""
#	endif
	macro	InitSpeed2	SpeedFieldInit;Vsms every:1000:PollSpeed
	macro	InitSpeed	eq? "$(GpsTruckLoaded)" "y" InitSpeed2
	/* Speed Message Feature */
	message SpeedMsg	n	/* change to y in Central.cfg to enable */
	symbol	SpeedMsgVel	223	/* can be overriden in Central.cfg */
	symbol	SpeedHigh	0
	macro	SpeedMsgChat	eq? $( max $(gpsVel) $(SpeedMsgVel) ) $(SpeedMsgVel) PostChat;eq? $( min $(gpsVel) $(SpeedMsgVel) ) $(SpeedMsgVel) PostNoChat
	macro	PostNoChat	ne? $(kbopen) n doPostNoChat; eq? $(kbopen) n doPreventChat
	macro	PostNoChat2	ne? $(qmopen) n doPostNoChat; eq? $(qmopen) n doPreventChat
	macro	doPostNoChat	postTrans "$(SpeedMsgLbl)";KBEEP 2
	macro	doPreventChat	postTrans "$(SpeedMsgLbl)";VS-EVENT 687996938 1 $(GpsTruck x) $(GpsTruck y) $(GpsTruck velocity)
        /* Speed Check Feature
         * This is a generic speed check that can be used with any action. A configuration symbol
         * is passed as first argument to check if speed check should be performed for action.
         * A positive macro (speed is below minimum) and a negative macro (speed above minimum)
         * to be executed are passed in as additional arguments. 
         * At some point Speed Message macros above should be deprecated and message functionality
         * should be refactored to use these
         */
        in      SpeedCheck     INT_RPC sss      eq? $1 y doSpeedCheck;ne? $1 y $2
        macro	doSpeedCheck	eq? $( max $(gpsVel) $(SpeedMsgVel) ) $(SpeedMsgVel) $2;eq? $( min $(gpsVel) $(SpeedMsgVel) ) $(SpeedMsgVel) $3
#else
	macro	InitSpeed	""
	message SpeedMsg	n
	macro	SpeedMsgChat	PostChat
	symbol	gpsVel		0
	symbol	SpeedMsgVel	223	/* can be overriden in Central.cfg */
        in      SpeedCheck     INT_RPC sss      $2
#endif
	/* Emergency Message Enhancement */
	/* This value gets overridden in client's Central.cfg: */
	message	BroadcastHelp	n
        message	EMERG_DELAY	10
	symbol	helpBcastOk	y
	symbol	EmergCnt
        symbol  myEmerg		n
	symbol	isEmergHit	n	/* Avoid multiple help requests by repeated button hits */
	macro	BcastHelp	myEmerg y;ne? "$(BroadcastHelp)" "y" HELP 911;\
				eq? "$(BroadcastHelp)" "y" KBCST 3 "field" "$(BcastMsg)$(EmergBcastMsg)";\
				eq? "$(BroadcastHelp)" "y" MESSAGE "$(BcastMsg)$(EmergBcastMsg)" "bcastmsg";\
				helpBcastOk n;isEmergHit n
	macro	CancelHelp	helpBcastOk n;isEmergHit n
	macro	doEmergency	eq? $(isEmergHit) n doConfirmHelp
        macro	doConfirmHelp	doConfirmHelp$(tbt_support)
	macro	chkEmergCnt	EmergCnt $(- $(EmergCnt) 1);MsgBox.Label label:"$(EmergOkLbl)";eq? $(helpBcastOk) y eq? $(max $(EmergCnt) 0) 0 autoSendEmerg;eq? $(helpBcastOk) y WinMgr after:1:chkEmergCnt
	macro	autoSendEmerg	WinMgr press:MsgBox.Btn1

#ifdef DELITE
	macro	UpdateStatBar1	StatBar.$1 label:$2
	macro	UpdateStatBar2  StatBar.$1 icon:$2

	/* This value gets overridden in client's Central.cfg: */
	message	TimeFormat	12

	message	TimeFormat12	%l:%M %p
	message	TimeFormat24	%k:%M
	symbol	CurrTime

	macro	UpdateTime	CurrTime $(Time get);WinMgr after:$(- 60 $(Time second)):UpdateTime

#	define VOLUMECONTROL_FILE	<VolumeControl/Macro.cfg>
#	include VOLUMECONTROL_FILE
	
	macro	StatBarInit	Time format:"$(TimeFormat$(TimeFormat))"; \
				UpdateTime;\
				InitVolumeControl
#else
	macro	UpdateStatBar1	InfoPanel setText:$1,$2
	macro	UpdateStatBar2  InfoPanel setImage:$1,$2
	macro	UpdateStatBar3  InfoPanel setColor:$1,$2
	macro	UpdateStatBar4	InfoPanel setSize:$1,$2
	macro	UpdateStatBar5	InfoPanel setWrapText:$1,$2
	macro	StatBarInit 	InfoPanel addColumn:1,3; \
				InfoPanel addColumn:2,3; \
				InfoPanel addObject:1,Operator,Small,White,Center; \
				InfoPanel addObject:2,Data,Small,White,Center
#endif
in	UpdateStatBar	INT_RPC	ss	UpdateStatBar1
in	UpdateStatBarImg	INT_RPC	ss	UpdateStatBar2
in	UpdateStatBarClr	INT_RPC	ss	UpdateStatBar3
in	UpdateStatBarSize	INT_RPC ss	UpdateStatBar4
in	UpdateStatBarWrap	INT_RPC	ss	UpdateStatBar5

/* Operator Safety Feedback */
#ifdef SHOWOPSAFEAREA
macro	doOpSafeNone	w0.FatgLbl label:"" map:n
macro	doOpSafeNorm	w0.FatgLbl colors:OpSafeNorm  map:y
macro	doOpSafePre	w0.FatgLbl colors:OpSafePre   map:y
macro	doOpSafeWarn	w0.FatgLbl colors:OpSafeWarn  map:y
macro	doOpSafeAlarm	w0.FatgLbl colors:OpSafeAlarm map:y
#endif

/* Non-truck tiedown: */
symbol  TiedownID
macro   doTiedownNotify     MessageBox "$(TiedownID)" "$(TiedownNotifyLbl)" "doTiedownAccept" "2Btn" "$(AcceptLbl)" "$(RejectLbl)" "doTiedownReject"
macro   doTiedownAccept     EQ-REQ tiedownaccept;KDISP "$(tiedownacptMsg)"
macro   doTiedownReject     EQ-REQ tiedownreject;KDISP "$(tiedownrejMsg)"

/* Favorites button */
symbol	enableFavorites	n
in	FavBtnAction	INT_RPC	s	UnpostWindow "Favorites";$1
macro	doFavorites	eq? $(enableFavorites) y PostFavorites;eq? $(enableFavorites) n doQuickMessage
macro	PostFavorites	PostWindow "Favorites" MENU_LAYER
macro	doFavoritesCancel	UnpostWindow "Favorites"

/* w0.CurAct and w0.ExpTime Font size adjustments */
macro InitFonts	w0.CurAct font:CurActFont; w0.ExpTime font:ExpTimeFont

/* StoreForward */
symbol	last_shvloc 'at unknown'
symbol	last_matl 'unknown_mat'
symbol	temp_gcdoarg ''

/* Turn By Turn Support */
symbol  tbt_support TBT_NO
symbol	showOperatorName 0
symbol	tbt_goto
symbol	kackState
symbol  prevState
symbol	kackMsg
symbol	TBTSwapSecs	10
symbol	notification_pending	no
macro   CheckShowOpName		eq? $(showOperatorName) 1 onShowDispatch;eq? $(showOperatorName) 0 SetOperatorLabel
macro	InitTurnByTurn          eq? $(ObjSh dispActive) yes tbt_support TBT_YES
macro	SetOperatorLabel        UpdateStatBarWrap "Operator" $(tbt_goto);notification_pending no
macro	ShowDispatch            ObjSh show
in      IsDispatchActive        INT_RPC ?s,s	return $(ObjSh dispActive)
macro	DispatchSwap		    ShowDispatch;WinMgr after:$(TBTSwapSecs):DispatchNotification
macro	DispatchNotification    ObjSh dispNotify
macro	CheckDispNotify		    eq? $(ObjSh dispActive) no ObjSh dispNotify
in	KackNotify INT_RPC s    DispatchSwap;MessageBox "$(kackMsg)" "$(PressOkLbl)" AckOk; \
                                WinMgr after:1:beepOn after:6:beepOff; \
                                notification_pending yes; \
                                WinMgr after:$(TBTSwapSecs):FinishKack
macro	FinishKack              UpdateStatBarClr "Operator" "Red";CheckShowOpName
macro	doKackMineCompass	    kackMsg $2;WinMgr after:5:KackNotify "$2"
macro	onShowDispatch	        UpdateStatBar "Operator" $(curr_oper);UpdateStatBarClr "Operator" "White"
macro	onShowMovingMap	        SetOperatorLabel
macro	onShowMovingMapWithPnl	showOperatorName $1;eq? $(showOperatorName) 1 onShowDispatch;eq? $(showOperatorName) 0 onShowMovingMap
macro	CheckMineCompass        WinMgr after:5:CheckMineCompass2
macro	CheckMineCompass2       eq? $(notification_pending) no eq? $(ObjSh mapActive) yes CheckShowOpName
macro	beepCheck               eq? $(ObjSh dispActive) no beepOff

macro	CheckPerspectiveTBT_YES	ne? $(state) 6 ne? $(state) 9 ne? $(prevState) $(state) eq? $(ObjSh mapActive) yes ShowDispatch; \
                                eq? $(state) 6 CheckMineCompass; \
                                eq? $(state) 9 CheckMineCompass; \
                                prevState $(state); \
                                ne? $(kackState) $(state) eq? $(MsgBox map) yes doMsgBoxClose;
macro	doKackTBT_YES           kackState $(state);eq? $(ObjSh mapActive) no doKackActive$(tbt_support); \
                                eq? $(ObjSh mapActive) yes doKackMineCompass
macro	doKdispTBT_YES          postTrans $1;do_kdisp_extra;eq? $(ObjSh mapActive) yes DispatchSwap
macro	doMaydayTBT_YES         MessageBox "$1" "$2" "$3";doEmrgFlash 1;EmrgFlash2;eq? $(ObjSh dispActive) no ShowDispatch;
macro	ShowOperatorTBT_YES     eq? $(ObjSh dispActive) yes UpdateStatBar "Operator" "$(curr_oper)"
macro	doKackActiveTBT_YES     GotAck 0;MessageBox "$2" "$(PressOkLbl)" AckOk; \
                                WinMgr after:$1:beepOn after:$(max $1 5):beepCheck after:30:AckIgnore;do_kack_extra
macro	doConfirmHelpTBT_YES	isEmergHit y;EmergCnt $(EMERG_DELAY);helpBcastOk y;\
				MessageBox "$(EmergOkLbl)" "$(ConfirmActLbl)" "BcastHelp" "2Btn" "$(SendNowLbl)" "$(CancelLbl)" "CancelHelp";\
				eq? $(ObjSh dispActive) no ShowDispatch;\
				WinMgr after:1:chkEmergCnt

macro	CheckPerspectiveTBT_NO	nil
macro	doKackTBT_NO	        doKackActive$(tbt_support)
macro	doKdispTBT_NO	        postTrans $1;do_kdisp_extra
macro	doMaydayTBT_NO	        MessageBox "$1" "$2" "$3";doEmrgFlash 1;EmrgFlash2
macro	ShowOperatorTBT_NO      UpdateStatBar "Operator" "$(curr_oper)"
macro	doKackActiveTBT_NO      GotAck 0;MessageBox "$2" "$(PressOkLbl)" AckOk;WinMgr after:$1:beepOn after:30:AckIgnore;do_kack_extra
macro	doConfirmHelpTBT_NO	isEmergHit y;EmergCnt $(EMERG_DELAY);helpBcastOk y;\
				MessageBox "$(EmergOkLbl)" "$(ConfirmActLbl)" "BcastHelp" "2Btn" "$(SendNowLbl)" "$(CancelLbl)" "CancelHelp";\
				WinMgr after:1:chkEmergCnt
/* End Turn By Turn Support */

macro InitDspIntegManager	""

macro   Init		Viewport map:n;StatBarInit;InitFonts; \
			InitSpeed;InitComms;InitGps;InitDspIntegManager; \
                        WinMgr after:10:PowerUp; \
                        WinMgr after:2:InitKeyboard; \
                        WinMgr after:3:InitPersist; \
                        WinMgr after:1:InitTurnByTurn; \
			PublishEquipmentName;

#define MOBILEAPI_FILE <10inch/common/MobileApiMacro.cfg>
#include MOBILEAPI_FILE

#define LANG_FILE	<10inch/common/LANGUAGE/Macro.cfg>
#include LANG_FILE
#define	APP_FILE	<10inch/APP/Macro.cfg>
#include APP_FILE
#include <10inch/Central.cfg>

#define OBJECT Macro
#include <Cfg/Options.cfg>

/* OEM Speed Support */
#include <10inch/common/OemSpeed.cfg>
macro  UseOemSpeed eq? "$(GpsTruckLoaded)" "y" GpsTruck UseOemSpeed:y; GpsTruck OemSpeedParamId:$(OEMSPEED_PARAM); 
